# Copyright (c) Mathias Kaerlev 2013-2017.
#
# This file is part of cuwo.
#
# cuwo is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cuwo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cuwo.  If not, see <http://www.gnu.org/licenses/>.

"""
tgen wrap

NOTE: This file is automatically generated. Do not modify.
"""


from cython cimport view
from libc.string cimport memset, memcpy, memcmp
from cuwo.vector import Vector3
from cuwo.common import filter_bytes
from cuwo import strings
from cuwo.bytes cimport ByteReader, ByteWriter
from cpython.object cimport PyObject
from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free
from cpython.ref cimport PyTypeObject, Py_INCREF, Py_XDECREF
import numpy as np

cdef extern from "numpy/arrayobject.h":
    object PyArray_NewFromDescr(PyTypeObject * subtype, np.dtype descr,
                                int nd, np.npy_intp* dims,
                                np.npy_intp* strides, void* data, int flags,
                                object obj)

cdef inline void set_array_base(np.ndarray arr, object base):
    cdef PyObject* baseptr
    if base is None:
        baseptr = NULL
    else:
        Py_INCREF(base)
        baseptr = <PyObject*>base
    Py_XDECREF(arr.base)
    arr.base = baseptr

cdef np.dtype dtype_float32 = np.dtype(np.float32) 
cdef np.dtype dtype_int32 = np.dtype(np.int32)
cdef np.dtype dtype_int64 = np.dtype(np.int64)
cdef np.npy_intp vec3_dim = 3

np.import_array()

cdef class MemoryHolder:
    def __dealloc__(self):
        PyMem_Free(self.data)



cdef class WrapItemUpgrade:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemUpgrade))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemUpgrade))
    def cast(self, object klass):
        cdef WrapItemUpgrade c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemUpgrade inst = WrapItemUpgrade.__new__(WrapItemUpgrade)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemUpgrade))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemUpgrade * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemUpgrade))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemUpgrade))
            return
        cdef ItemUpgrade * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemUpgrade))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemUpgrade))
        self._set_ptr(<ItemUpgrade*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemUpgrade))
        self._init_ptr(<ItemUpgrade*>buf)
    @property
    def x(self):
        return self.data[0].x
    @x.setter
    def x(self, value):
        self.data[0].x = value
    @property
    def y(self):
        return self.data[0].y
    @y.setter
    def y(self, value):
        self.data[0].y = value
    @property
    def z(self):
        return self.data[0].z
    @z.setter
    def z(self, value):
        self.data[0].z = value
    @property
    def material(self):
        return self.data[0].material
    @material.setter
    def material(self, value):
        self.data[0].material = value
    @property
    def level(self):
        return self.data[0].level
    @level.setter
    def level(self, value):
        self.data[0].level = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ItemUpgrade * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemUpgrade * ptr):
        self.data = ptr
    def set_ptr(self, WrapItemUpgrade v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItemData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemData))
    def cast(self, object klass):
        cdef WrapItemData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemData inst = WrapItemData.__new__(WrapItemData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemData))
            return
        cdef ItemData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemData))
        self._set_ptr(<ItemData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemData))
        self._init_ptr(<ItemData*>buf)
    @property
    def type(self):
        return self.data[0].type
    @type.setter
    def type(self, value):
        self.data[0].type = value
    @property
    def sub_type(self):
        return self.data[0].sub_type
    @sub_type.setter
    def sub_type(self, value):
        self.data[0].sub_type = value
    @property
    def modifier(self):
        return self.data[0].modifier
    @modifier.setter
    def modifier(self, value):
        self.data[0].modifier = value
    @property
    def minus_modifier(self):
        return self.data[0].minus_modifier
    @minus_modifier.setter
    def minus_modifier(self, value):
        self.data[0].minus_modifier = value
    @property
    def rarity(self):
        return self.data[0].rarity
    @rarity.setter
    def rarity(self, value):
        self.data[0].rarity = value
    @property
    def material(self):
        return self.data[0].material
    @material.setter
    def material(self, value):
        self.data[0].material = value
    @property
    def flags(self):
        return self.data[0].flags
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def level(self):
        return self.data[0].level
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def items(self):
        if self._items is not None:
            return self._items
        self._items = WrapArray0.__new__(WrapArray0)
        self._items.holder = self.holder
        self._items._init_ptr(&self.data[0].items[0])
        return self._items
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def upgrade_count(self):
        return self.data[0].upgrade_count
    @upgrade_count.setter
    def upgrade_count(self, value):
        self.data[0].upgrade_count = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].level = 1
    cdef void _init_ptr(self, ItemData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemData * ptr):
        self.data = ptr
        if self._items is not None:
            self._items.holder = self.holder
            self._items._set_ptr(&self.data[0].items[0])
    def set_ptr(self, WrapItemData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapAppearanceData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(AppearanceData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(AppearanceData))
    def cast(self, object klass):
        cdef WrapAppearanceData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapAppearanceData inst = WrapAppearanceData.__new__(WrapAppearanceData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(AppearanceData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef AppearanceData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(AppearanceData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(AppearanceData))
            return
        cdef AppearanceData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(AppearanceData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(AppearanceData))
        self._set_ptr(<AppearanceData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(AppearanceData))
        self._init_ptr(<AppearanceData*>buf)
    @property
    def not_used_1(self):
        return self.data[0].not_used_1
    @not_used_1.setter
    def not_used_1(self, value):
        self.data[0].not_used_1 = value
    @property
    def not_used_2(self):
        return self.data[0].not_used_2
    @not_used_2.setter
    def not_used_2(self, value):
        self.data[0].not_used_2 = value
    @property
    def hair_red(self):
        return self.data[0].hair_red
    @hair_red.setter
    def hair_red(self, value):
        self.data[0].hair_red = value
    @property
    def hair_green(self):
        return self.data[0].hair_green
    @hair_green.setter
    def hair_green(self, value):
        self.data[0].hair_green = value
    @property
    def hair_blue(self):
        return self.data[0].hair_blue
    @hair_blue.setter
    def hair_blue(self, value):
        self.data[0].hair_blue = value
    @property
    def flags(self):
        return self.data[0].flags
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def scale(self):
        if self._scale is not None:
            return self._scale
        Py_INCREF(dtype_float32)
        cdef float * scaleptr = &self.data[0].scale[0]
        self._scale = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>scaleptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._scale, self.holder)
        return self._scale
    @scale.setter
    def scale(self, value):
        cdef float[3] arr = value
        self.data[0].scale = arr
    @property
    def head_model(self):
        return self.data[0].head_model
    @head_model.setter
    def head_model(self, value):
        self.data[0].head_model = value
    @property
    def hair_model(self):
        return self.data[0].hair_model
    @hair_model.setter
    def hair_model(self, value):
        self.data[0].hair_model = value
    @property
    def hand_model(self):
        return self.data[0].hand_model
    @hand_model.setter
    def hand_model(self, value):
        self.data[0].hand_model = value
    @property
    def foot_model(self):
        return self.data[0].foot_model
    @foot_model.setter
    def foot_model(self, value):
        self.data[0].foot_model = value
    @property
    def body_model(self):
        return self.data[0].body_model
    @body_model.setter
    def body_model(self, value):
        self.data[0].body_model = value
    @property
    def tail_model(self):
        return self.data[0].tail_model
    @tail_model.setter
    def tail_model(self, value):
        self.data[0].tail_model = value
    @property
    def shoulder2_model(self):
        return self.data[0].shoulder2_model
    @shoulder2_model.setter
    def shoulder2_model(self, value):
        self.data[0].shoulder2_model = value
    @property
    def wing_model(self):
        return self.data[0].wing_model
    @wing_model.setter
    def wing_model(self, value):
        self.data[0].wing_model = value
    @property
    def head_scale(self):
        return self.data[0].head_scale
    @head_scale.setter
    def head_scale(self, value):
        self.data[0].head_scale = value
    @property
    def body_scale(self):
        return self.data[0].body_scale
    @body_scale.setter
    def body_scale(self, value):
        self.data[0].body_scale = value
    @property
    def hand_scale(self):
        return self.data[0].hand_scale
    @hand_scale.setter
    def hand_scale(self, value):
        self.data[0].hand_scale = value
    @property
    def foot_scale(self):
        return self.data[0].foot_scale
    @foot_scale.setter
    def foot_scale(self, value):
        self.data[0].foot_scale = value
    @property
    def shoulder2_scale(self):
        return self.data[0].shoulder2_scale
    @shoulder2_scale.setter
    def shoulder2_scale(self, value):
        self.data[0].shoulder2_scale = value
    @property
    def weapon_scale(self):
        return self.data[0].weapon_scale
    @weapon_scale.setter
    def weapon_scale(self, value):
        self.data[0].weapon_scale = value
    @property
    def tail_scale(self):
        return self.data[0].tail_scale
    @tail_scale.setter
    def tail_scale(self, value):
        self.data[0].tail_scale = value
    @property
    def shoulder_scale(self):
        return self.data[0].shoulder_scale
    @shoulder_scale.setter
    def shoulder_scale(self, value):
        self.data[0].shoulder_scale = value
    @property
    def wing_scale(self):
        return self.data[0].wing_scale
    @wing_scale.setter
    def wing_scale(self, value):
        self.data[0].wing_scale = value
    @property
    def body_pitch(self):
        return self.data[0].body_pitch
    @body_pitch.setter
    def body_pitch(self, value):
        self.data[0].body_pitch = value
    @property
    def arm_pitch(self):
        return self.data[0].arm_pitch
    @arm_pitch.setter
    def arm_pitch(self, value):
        self.data[0].arm_pitch = value
    @property
    def arm_roll(self):
        return self.data[0].arm_roll
    @arm_roll.setter
    def arm_roll(self, value):
        self.data[0].arm_roll = value
    @property
    def arm_yaw(self):
        return self.data[0].arm_yaw
    @arm_yaw.setter
    def arm_yaw(self, value):
        self.data[0].arm_yaw = value
    @property
    def feet_pitch(self):
        return self.data[0].feet_pitch
    @feet_pitch.setter
    def feet_pitch(self, value):
        self.data[0].feet_pitch = value
    @property
    def wing_pitch(self):
        return self.data[0].wing_pitch
    @wing_pitch.setter
    def wing_pitch(self, value):
        self.data[0].wing_pitch = value
    @property
    def back_pitch(self):
        return self.data[0].back_pitch
    @back_pitch.setter
    def back_pitch(self, value):
        self.data[0].back_pitch = value
    @property
    def body_offset(self):
        if self._body_offset is not None:
            return self._body_offset
        Py_INCREF(dtype_float32)
        cdef float * body_offsetptr = &self.data[0].body_offset[0]
        self._body_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>body_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._body_offset, self.holder)
        return self._body_offset
    @body_offset.setter
    def body_offset(self, value):
        cdef float[3] arr = value
        self.data[0].body_offset = arr
    @property
    def head_offset(self):
        if self._head_offset is not None:
            return self._head_offset
        Py_INCREF(dtype_float32)
        cdef float * head_offsetptr = &self.data[0].head_offset[0]
        self._head_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>head_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._head_offset, self.holder)
        return self._head_offset
    @head_offset.setter
    def head_offset(self, value):
        cdef float[3] arr = value
        self.data[0].head_offset = arr
    @property
    def hand_offset(self):
        if self._hand_offset is not None:
            return self._hand_offset
        Py_INCREF(dtype_float32)
        cdef float * hand_offsetptr = &self.data[0].hand_offset[0]
        self._hand_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>hand_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._hand_offset, self.holder)
        return self._hand_offset
    @hand_offset.setter
    def hand_offset(self, value):
        cdef float[3] arr = value
        self.data[0].hand_offset = arr
    @property
    def foot_offset(self):
        if self._foot_offset is not None:
            return self._foot_offset
        Py_INCREF(dtype_float32)
        cdef float * foot_offsetptr = &self.data[0].foot_offset[0]
        self._foot_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>foot_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._foot_offset, self.holder)
        return self._foot_offset
    @foot_offset.setter
    def foot_offset(self, value):
        cdef float[3] arr = value
        self.data[0].foot_offset = arr
    @property
    def tail_offset(self):
        if self._tail_offset is not None:
            return self._tail_offset
        Py_INCREF(dtype_float32)
        cdef float * tail_offsetptr = &self.data[0].tail_offset[0]
        self._tail_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>tail_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._tail_offset, self.holder)
        return self._tail_offset
    @tail_offset.setter
    def tail_offset(self, value):
        cdef float[3] arr = value
        self.data[0].tail_offset = arr
    @property
    def wing_offset(self):
        if self._wing_offset is not None:
            return self._wing_offset
        Py_INCREF(dtype_float32)
        cdef float * wing_offsetptr = &self.data[0].wing_offset[0]
        self._wing_offset = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>wing_offsetptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._wing_offset, self.holder)
        return self._wing_offset
    @wing_offset.setter
    def wing_offset(self, value):
        cdef float[3] arr = value
        self.data[0].wing_offset = arr
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].hair_red = 255
        self.data[0].hair_green = 255
        self.data[0].hair_blue = 255
        self.data[0].head_model = -1
        self.data[0].hair_model = -1
        self.data[0].hand_model = -1
        self.data[0].foot_model = -1
        self.data[0].body_model = -1
        self.data[0].tail_model = -1
        self.data[0].shoulder2_model = -1
        self.data[0].wing_model = -1
    cdef void _init_ptr(self, AppearanceData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, AppearanceData * ptr):
        self.data = ptr
        if self._scale is not None:
            set_array_base(self._scale, self.holder)
            self._scale.data = <char*>&self.data[0].scale
        if self._body_offset is not None:
            set_array_base(self._body_offset, self.holder)
            self._body_offset.data = <char*>&self.data[0].body_offset
        if self._head_offset is not None:
            set_array_base(self._head_offset, self.holder)
            self._head_offset.data = <char*>&self.data[0].head_offset
        if self._hand_offset is not None:
            set_array_base(self._hand_offset, self.holder)
            self._hand_offset.data = <char*>&self.data[0].hand_offset
        if self._foot_offset is not None:
            set_array_base(self._foot_offset, self.holder)
            self._foot_offset.data = <char*>&self.data[0].foot_offset
        if self._tail_offset is not None:
            set_array_base(self._tail_offset, self.holder)
            self._tail_offset.data = <char*>&self.data[0].tail_offset
        if self._wing_offset is not None:
            set_array_base(self._wing_offset, self.holder)
            self._wing_offset.data = <char*>&self.data[0].wing_offset
    def set_ptr(self, WrapAppearanceData v):
        self.holder = v.holder
        self._set_ptr(v.data)

    def get_head(self):
        return strings.MODEL_NAMES[self.data[0].head_model]

    def set_head(self, name):
        self.data[0].head_model = strings.MODEL_IDS[name]

    def get_hair(self):
        return strings.MODEL_NAMES[self.data[0].hair_model]

    def set_hair(self, name):
        self.data[0].hair_model = strings.MODEL_IDS[name]

    def get_hand(self):
        return strings.MODEL_NAMES[self.data[0].hand_model]

    def set_hand(self, name):
        self.data[0].hand_model = strings.MODEL_IDS[name]

    def get_foot(self):
        return strings.MODEL_NAMES[self.data[0].foot_model]

    def set_foot(self, name):
        self.data[0].foot_model = strings.MODEL_IDS[name]

    def get_body(self):
        return strings.MODEL_NAMES[self.data[0].body_model]

    def set_body(self, name):
        self.data[0].body_model = strings.MODEL_IDS[name]

    def get_tail(self):
        return strings.MODEL_NAMES[self.data[0].tail_model]

    def set_tail(self, name):
        self.data[0].tail_model = strings.MODEL_IDS[name]

    def get_shoulder2(self):
        return strings.MODEL_NAMES[self.data[0].shoulder2_model]

    def set_shoulder2(self, name):
        self.data[0].shoulder2_model = strings.MODEL_IDS[name]

    def get_wing(self):
        return strings.MODEL_NAMES[self.data[0].wing_model]

    def set_wing(self, name):
        self.data[0].wing_model = strings.MODEL_IDS[name]
POS_BIT = 0
POS_FLAG = 0x1
ORIENT_BIT = 1
ORIENT_FLAG = 0x2
VEL_BIT = 2
VEL_FLAG = 0x4
ACCEL_BIT = 3
ACCEL_FLAG = 0x8
EXTRA_VEL_BIT = 4
EXTRA_VEL_FLAG = 0x10
LOOK_PITCH_BIT = 5
LOOK_PITCH_FLAG = 0x20
PHYSICS_BIT = 6
PHYSICS_FLAG = 0x40
HOSTILE_BIT = 7
HOSTILE_FLAG = 0x80
TYPE_BIT = 8
TYPE_FLAG = 0x100
MODE_BIT = 9
MODE_FLAG = 0x200
MODE_TIME_BIT = 10
MODE_TIME_FLAG = 0x400
HIT_COUNTER_BIT = 11
HIT_COUNTER_FLAG = 0x800
LAST_HIT_BIT = 12
LAST_HIT_FLAG = 0x1000
APPEARANCE_BIT = 13
APPEARANCE_FLAG = 0x2000
FLAGS_BIT = 14
FLAGS_FLAG = 0x4000
ROLL_BIT = 15
ROLL_FLAG = 0x8000
STUN_BIT = 16
STUN_FLAG = 0x10000
SLOWED_BIT = 17
SLOWED_FLAG = 0x20000
MAKE_BLUE_BIT = 18
MAKE_BLUE_FLAG = 0x40000
SPEED_UP_BIT = 19
SPEED_UP_FLAG = 0x80000
SHOW_PATCH_BIT = 20
SHOW_PATCH_FLAG = 0x100000
CLASS_BIT = 21
CLASS_FLAG = 0x200000
SPECIALIZATION_BIT = 22
SPECIALIZATION_FLAG = 0x400000
CHARGED_MP_BIT = 23
CHARGED_MP_FLAG = 0x800000
RAY_BIT = 26
RAY_FLAG = 0x4000000
HP_BIT = 27
HP_FLAG = 0x8000000
MP_BIT = 28
MP_FLAG = 0x10000000
BLOCK_POWER_BIT = 29
BLOCK_POWER_FLAG = 0x20000000
MULTIPLIER_BIT = 30
MULTIPLIER_FLAG = 0x40000000
LEVEL_BIT = 33
LEVEL_FLAG = 0x200000000
XP_BIT = 34
XP_FLAG = 0x400000000
OWNER_BIT = 35
OWNER_FLAG = 0x800000000
POWER_BASE_BIT = 37
POWER_BASE_FLAG = 0x2000000000
START_CHUNK_BIT = 39
START_CHUNK_FLAG = 0x8000000000
SPAWN_BIT = 40
SPAWN_FLAG = 0x10000000000
CONSUMABLE_BIT = 43
CONSUMABLE_FLAG = 0x80000000000
EQUIPMENT_BIT = 44
EQUIPMENT_FLAG = 0x100000000000
NAME_BIT = 45
NAME_FLAG = 0x200000000000
SKILL_BIT = 46
SKILL_FLAG = 0x400000000000
MANA_CUBES_BIT = 47
MANA_CUBES_FLAG = 0x800000000000


cdef class WrapEntityData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(EntityData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(EntityData))
    def cast(self, object klass):
        cdef WrapEntityData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapEntityData inst = WrapEntityData.__new__(WrapEntityData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(EntityData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef EntityData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(EntityData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(EntityData))
            return
        cdef EntityData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(EntityData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(EntityData))
        self._set_ptr(<EntityData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(EntityData))
        self._init_ptr(<EntityData*>buf)
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def body_roll(self):
        return self.data[0].body_roll
    @body_roll.setter
    def body_roll(self, value):
        self.data[0].body_roll = value
    @property
    def body_pitch(self):
        return self.data[0].body_pitch
    @body_pitch.setter
    def body_pitch(self, value):
        self.data[0].body_pitch = value
    @property
    def body_yaw(self):
        return self.data[0].body_yaw
    @body_yaw.setter
    def body_yaw(self, value):
        self.data[0].body_yaw = value
    @property
    def velocity(self):
        if self._velocity is not None:
            return self._velocity
        Py_INCREF(dtype_float32)
        cdef float * velocityptr = &self.data[0].velocity[0]
        self._velocity = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>velocityptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._velocity, self.holder)
        return self._velocity
    @velocity.setter
    def velocity(self, value):
        cdef float[3] arr = value
        self.data[0].velocity = arr
    @property
    def accel(self):
        if self._accel is not None:
            return self._accel
        Py_INCREF(dtype_float32)
        cdef float * accelptr = &self.data[0].accel[0]
        self._accel = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>accelptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._accel, self.holder)
        return self._accel
    @accel.setter
    def accel(self, value):
        cdef float[3] arr = value
        self.data[0].accel = arr
    @property
    def extra_vel(self):
        if self._extra_vel is not None:
            return self._extra_vel
        Py_INCREF(dtype_float32)
        cdef float * extra_velptr = &self.data[0].extra_vel[0]
        self._extra_vel = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>extra_velptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._extra_vel, self.holder)
        return self._extra_vel
    @extra_vel.setter
    def extra_vel(self, value):
        cdef float[3] arr = value
        self.data[0].extra_vel = arr
    @property
    def look_pitch(self):
        return self.data[0].look_pitch
    @look_pitch.setter
    def look_pitch(self, value):
        self.data[0].look_pitch = value
    @property
    def physics_flags(self):
        return self.data[0].physics_flags
    @physics_flags.setter
    def physics_flags(self, value):
        self.data[0].physics_flags = value
    @property
    def hostile_type(self):
        return self.data[0].hostile_type
    @hostile_type.setter
    def hostile_type(self, value):
        self.data[0].hostile_type = value
    @property
    def entity_type(self):
        return self.data[0].entity_type
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def current_mode(self):
        return self.data[0].current_mode
    @current_mode.setter
    def current_mode(self, value):
        self.data[0].current_mode = value
    @property
    def mode_start_time(self):
        return self.data[0].mode_start_time
    @mode_start_time.setter
    def mode_start_time(self, value):
        self.data[0].mode_start_time = value
    @property
    def hit_counter(self):
        return self.data[0].hit_counter
    @hit_counter.setter
    def hit_counter(self, value):
        self.data[0].hit_counter = value
    @property
    def last_hit_time(self):
        return self.data[0].last_hit_time
    @last_hit_time.setter
    def last_hit_time(self, value):
        self.data[0].last_hit_time = value
    @property
    def appearance(self):
        if self._appearance is not None:
            return self._appearance
        self._appearance = WrapAppearanceData.__new__(WrapAppearanceData)
        self._appearance.holder = self.holder
        self._appearance._init_ptr(&self.data[0].appearance)
        return self._appearance
    @appearance.setter
    def appearance(self, value):
        cdef WrapAppearanceData v = value
        self.data[0].appearance = v.data[0]
    @property
    def flags(self):
        return self.data[0].flags
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def roll_time(self):
        return self.data[0].roll_time
    @roll_time.setter
    def roll_time(self, value):
        self.data[0].roll_time = value
    @property
    def stun_time(self):
        return self.data[0].stun_time
    @stun_time.setter
    def stun_time(self, value):
        self.data[0].stun_time = value
    @property
    def slowed_time(self):
        return self.data[0].slowed_time
    @slowed_time.setter
    def slowed_time(self, value):
        self.data[0].slowed_time = value
    @property
    def make_blue_time(self):
        return self.data[0].make_blue_time
    @make_blue_time.setter
    def make_blue_time(self, value):
        self.data[0].make_blue_time = value
    @property
    def speed_up_time(self):
        return self.data[0].speed_up_time
    @speed_up_time.setter
    def speed_up_time(self, value):
        self.data[0].speed_up_time = value
    @property
    def show_patch_time(self):
        return self.data[0].show_patch_time
    @show_patch_time.setter
    def show_patch_time(self, value):
        self.data[0].show_patch_time = value
    @property
    def class_type(self):
        return self.data[0].class_type
    @class_type.setter
    def class_type(self, value):
        self.data[0].class_type = value
    @property
    def specialization(self):
        return self.data[0].specialization
    @specialization.setter
    def specialization(self, value):
        self.data[0].specialization = value
    @property
    def charged_mp(self):
        return self.data[0].charged_mp
    @charged_mp.setter
    def charged_mp(self, value):
        self.data[0].charged_mp = value
    @property
    def not_used_1(self):
        return self.data[0].not_used_1
    @not_used_1.setter
    def not_used_1(self, value):
        self.data[0].not_used_1 = value
    @property
    def not_used_2(self):
        return self.data[0].not_used_2
    @not_used_2.setter
    def not_used_2(self, value):
        self.data[0].not_used_2 = value
    @property
    def not_used_3(self):
        return self.data[0].not_used_3
    @not_used_3.setter
    def not_used_3(self, value):
        self.data[0].not_used_3 = value
    @property
    def not_used_4(self):
        return self.data[0].not_used_4
    @not_used_4.setter
    def not_used_4(self, value):
        self.data[0].not_used_4 = value
    @property
    def not_used_5(self):
        return self.data[0].not_used_5
    @not_used_5.setter
    def not_used_5(self, value):
        self.data[0].not_used_5 = value
    @property
    def not_used_6(self):
        return self.data[0].not_used_6
    @not_used_6.setter
    def not_used_6(self, value):
        self.data[0].not_used_6 = value
    @property
    def ray_hit(self):
        if self._ray_hit is not None:
            return self._ray_hit
        Py_INCREF(dtype_float32)
        cdef float * ray_hitptr = &self.data[0].ray_hit[0]
        self._ray_hit = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>ray_hitptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._ray_hit, self.holder)
        return self._ray_hit
    @ray_hit.setter
    def ray_hit(self, value):
        cdef float[3] arr = value
        self.data[0].ray_hit = arr
    @property
    def hp(self):
        return self.data[0].hp
    @hp.setter
    def hp(self, value):
        self.data[0].hp = value
    @property
    def mp(self):
        return self.data[0].mp
    @mp.setter
    def mp(self, value):
        self.data[0].mp = value
    @property
    def block_power(self):
        return self.data[0].block_power
    @block_power.setter
    def block_power(self, value):
        self.data[0].block_power = value
    @property
    def max_hp_multiplier(self):
        return self.data[0].max_hp_multiplier
    @max_hp_multiplier.setter
    def max_hp_multiplier(self, value):
        self.data[0].max_hp_multiplier = value
    @property
    def shoot_speed(self):
        return self.data[0].shoot_speed
    @shoot_speed.setter
    def shoot_speed(self, value):
        self.data[0].shoot_speed = value
    @property
    def damage_multiplier(self):
        return self.data[0].damage_multiplier
    @damage_multiplier.setter
    def damage_multiplier(self, value):
        self.data[0].damage_multiplier = value
    @property
    def armor_multiplier(self):
        return self.data[0].armor_multiplier
    @armor_multiplier.setter
    def armor_multiplier(self, value):
        self.data[0].armor_multiplier = value
    @property
    def resi_multiplier(self):
        return self.data[0].resi_multiplier
    @resi_multiplier.setter
    def resi_multiplier(self, value):
        self.data[0].resi_multiplier = value
    @property
    def not_used7(self):
        return self.data[0].not_used7
    @not_used7.setter
    def not_used7(self, value):
        self.data[0].not_used7 = value
    @property
    def not_used8(self):
        return self.data[0].not_used8
    @not_used8.setter
    def not_used8(self, value):
        self.data[0].not_used8 = value
    @property
    def level(self):
        return self.data[0].level
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def current_xp(self):
        return self.data[0].current_xp
    @current_xp.setter
    def current_xp(self, value):
        self.data[0].current_xp = value
    @property
    def parent_owner(self):
        return self.data[0].parent_owner
    @parent_owner.setter
    def parent_owner(self, value):
        self.data[0].parent_owner = value
    @property
    def unknown_or_not_used1(self):
        return self.data[0].unknown_or_not_used1
    @unknown_or_not_used1.setter
    def unknown_or_not_used1(self, value):
        self.data[0].unknown_or_not_used1 = value
    @property
    def unknown_or_not_used2(self):
        return self.data[0].unknown_or_not_used2
    @unknown_or_not_used2.setter
    def unknown_or_not_used2(self, value):
        self.data[0].unknown_or_not_used2 = value
    @property
    def power_base(self):
        return self.data[0].power_base
    @power_base.setter
    def power_base(self, value):
        self.data[0].power_base = value
    @property
    def unknown_or_not_used4(self):
        return self.data[0].unknown_or_not_used4
    @unknown_or_not_used4.setter
    def unknown_or_not_used4(self, value):
        self.data[0].unknown_or_not_used4 = value
    @property
    def start_chunk(self):
        if self._start_chunk is not None:
            return self._start_chunk
        Py_INCREF(dtype_int32)
        cdef int32_t * start_chunkptr = &self.data[0].start_chunk[0]
        self._start_chunk = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int32, 1, &vec3_dim, NULL, <void*>start_chunkptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._start_chunk, self.holder)
        return self._start_chunk
    @start_chunk.setter
    def start_chunk(self, value):
        cdef int32_t[3] arr = value
        self.data[0].start_chunk = arr
    @property
    def super_weird(self):
        return self.data[0].super_weird
    @super_weird.setter
    def super_weird(self, value):
        self.data[0].super_weird = value
    @property
    def spawn_pos(self):
        if self._spawn_pos is not None:
            return self._spawn_pos
        Py_INCREF(dtype_int64)
        cdef int64_t * spawn_posptr = &self.data[0].spawn_pos[0]
        self._spawn_pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>spawn_posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._spawn_pos, self.holder)
        return self._spawn_pos
    @spawn_pos.setter
    def spawn_pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].spawn_pos = arr
    @property
    def not_used19(self):
        return self.data[0].not_used19
    @not_used19.setter
    def not_used19(self, value):
        self.data[0].not_used19 = value
    @property
    def not_used20(self):
        if self._not_used20 is not None:
            return self._not_used20
        Py_INCREF(dtype_int32)
        cdef int32_t * not_used20ptr = &self.data[0].not_used20[0]
        self._not_used20 = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int32, 1, &vec3_dim, NULL, <void*>not_used20ptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._not_used20, self.holder)
        return self._not_used20
    @not_used20.setter
    def not_used20(self, value):
        cdef int32_t[3] arr = value
        self.data[0].not_used20 = arr
    @property
    def consumable(self):
        if self._consumable is not None:
            return self._consumable
        self._consumable = WrapItemData.__new__(WrapItemData)
        self._consumable.holder = self.holder
        self._consumable._init_ptr(&self.data[0].consumable)
        return self._consumable
    @consumable.setter
    def consumable(self, value):
        cdef WrapItemData v = value
        self.data[0].consumable = v.data[0]
    @property
    def equipment(self):
        if self._equipment is not None:
            return self._equipment
        self._equipment = WrapArray1.__new__(WrapArray1)
        self._equipment.holder = self.holder
        self._equipment._init_ptr(&self.data[0].equipment[0])
        return self._equipment
    @equipment.setter
    def equipment(self, value):
        raise NotImplementedError()
    @property
    def skills(self):
        if self._skills is not None:
            return self._skills
        self._skills = <uint32_t[:11]>(&self.data[0].skills[0])
        return self._skills
    @skills.setter
    def skills(self, value):
        raise NotImplementedError()
    @property
    def mana_cubes(self):
        return self.data[0].mana_cubes
    @mana_cubes.setter
    def mana_cubes(self, value):
        self.data[0].mana_cubes = value
    @property
    def name(self):
        cdef int i = 0
        while i < 16:
            if self.data[0].name[i] == 0: break
            i += 1
        return filter_bytes(self.data[0].name[:i])
    @name.setter
    def name(self, value):
        cdef str v = value
        cdef bytes vv = v.encode('ascii', 'ignore')[:16]
        cdef const char * c = vv
        cdef size_t size = len(vv)
        cdef int i
        for i in range(16):
            if i >= size:
                self.data[0].name[i] = 0
            else:
                self.data[0].name[i] = c[i]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].hostile_type = 3
        self.data[0].stun_time = -3000
        self.data[0].hp = 500
        self.data[0].max_hp_multiplier = 100
        self.data[0].damage_multiplier = 1
        self.data[0].armor_multiplier = 1
        self.data[0].resi_multiplier = 1
        self.data[0].unknown_or_not_used4 = -1
        self.data[0].start_chunk = (-1, -1, 0)
        self.data[0].not_used20 = (-1, -1, 0)
    cdef void _init_ptr(self, EntityData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, EntityData * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._velocity is not None:
            set_array_base(self._velocity, self.holder)
            self._velocity.data = <char*>&self.data[0].velocity
        if self._accel is not None:
            set_array_base(self._accel, self.holder)
            self._accel.data = <char*>&self.data[0].accel
        if self._extra_vel is not None:
            set_array_base(self._extra_vel, self.holder)
            self._extra_vel.data = <char*>&self.data[0].extra_vel
        if self._appearance is not None:
            self._appearance.holder = self.holder
            self._appearance._set_ptr(&self.data[0].appearance)
        if self._ray_hit is not None:
            set_array_base(self._ray_hit, self.holder)
            self._ray_hit.data = <char*>&self.data[0].ray_hit
        if self._start_chunk is not None:
            set_array_base(self._start_chunk, self.holder)
            self._start_chunk.data = <char*>&self.data[0].start_chunk
        if self._spawn_pos is not None:
            set_array_base(self._spawn_pos, self.holder)
            self._spawn_pos.data = <char*>&self.data[0].spawn_pos
        if self._not_used20 is not None:
            set_array_base(self._not_used20, self.holder)
            self._not_used20.data = <char*>&self.data[0].not_used20
        if self._consumable is not None:
            self._consumable.holder = self.holder
            self._consumable._set_ptr(&self.data[0].consumable)
        if self._equipment is not None:
            self._equipment.holder = self.holder
            self._equipment._set_ptr(&self.data[0].equipment[0])
        if self._skills is not None:
            self._skills.data = <char*>(&self.data[0].skills[0])
    def set_ptr(self, WrapEntityData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItemWithHeader:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeader))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeader))
    def cast(self, object klass):
        cdef WrapItemWithHeader c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemWithHeader inst = WrapItemWithHeader.__new__(WrapItemWithHeader)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeader))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemWithHeader * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemWithHeader))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemWithHeader))
            return
        cdef ItemWithHeader * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemWithHeader))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeader))
        self._set_ptr(<ItemWithHeader*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeader))
        self._init_ptr(<ItemWithHeader*>buf)
    @property
    def header(self):
        return self.data[0].header
    @header.setter
    def header(self, value):
        self.data[0].header = value
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapItemData.__new__(WrapItemData)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapItemData v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ItemWithHeader * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemWithHeader * ptr):
        self.data = ptr
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapItemWithHeader v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItemWithHeaderList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeaderList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeaderList))
    def cast(self, object klass):
        cdef WrapItemWithHeaderList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemWithHeaderList inst = WrapItemWithHeaderList.__new__(WrapItemWithHeaderList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeaderList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemWithHeaderList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemWithHeaderList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemWithHeaderList))
            return
        cdef ItemWithHeaderList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemWithHeaderList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeaderList))
        self._set_ptr(<ItemWithHeaderList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeaderList))
        self._init_ptr(<ItemWithHeaderList*>buf)
    @property
    def vec(self):
        if self._vec is not None:
            return self._vec
        self._vec = WrapItemWithHeaderVec.__new__(WrapItemWithHeaderVec)
        self._vec.holder = self.holder
        self._vec._init_ptr(&self.data[0].vec_start)
        return self._vec
    @vec.setter
    def vec(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ItemWithHeaderList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemWithHeaderList * ptr):
        self.data = ptr
        if self._vec is not None:
            self._vec.holder = self.holder
            self._vec._set_ptr(&self.data[0].vec_start)
    def set_ptr(self, WrapItemWithHeaderList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItemWithHeaderLists:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeaderLists))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeaderLists))
    def cast(self, object klass):
        cdef WrapItemWithHeaderLists c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemWithHeaderLists inst = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeaderLists))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemWithHeaderLists * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemWithHeaderLists))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemWithHeaderLists))
            return
        cdef ItemWithHeaderLists * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemWithHeaderLists))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeaderLists))
        self._set_ptr(<ItemWithHeaderLists*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithHeaderLists))
        self._init_ptr(<ItemWithHeaderLists*>buf)
    @property
    def vec(self):
        if self._vec is not None:
            return self._vec
        self._vec = WrapItemWithHeaderListVec.__new__(WrapItemWithHeaderListVec)
        self._vec.holder = self.holder
        self._vec._init_ptr(&self.data[0].vec_start)
        return self._vec
    @vec.setter
    def vec(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ItemWithHeaderLists * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemWithHeaderLists * ptr):
        self.data = ptr
        if self._vec is not None:
            self._vec.holder = self.holder
            self._vec._set_ptr(&self.data[0].vec_start)
    def set_ptr(self, WrapItemWithHeaderLists v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapStaticEntityHeader:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(StaticEntityHeader))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(StaticEntityHeader))
    def cast(self, object klass):
        cdef WrapStaticEntityHeader c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapStaticEntityHeader inst = WrapStaticEntityHeader.__new__(WrapStaticEntityHeader)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(StaticEntityHeader))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef StaticEntityHeader * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(StaticEntityHeader))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(StaticEntityHeader))
            return
        cdef StaticEntityHeader * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(StaticEntityHeader))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntityHeader))
        self._set_ptr(<StaticEntityHeader*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntityHeader))
        self._init_ptr(<StaticEntityHeader*>buf)
    @property
    def entity_type(self):
        return self.data[0].entity_type
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def orientation(self):
        return self.data[0].orientation
    @orientation.setter
    def orientation(self, value):
        self.data[0].orientation = value
    @property
    def size(self):
        if self._size is not None:
            return self._size
        Py_INCREF(dtype_float32)
        cdef float * sizeptr = &self.data[0].size[0]
        self._size = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>sizeptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._size, self.holder)
        return self._size
    @size.setter
    def size(self, value):
        cdef float[3] arr = value
        self.data[0].size = arr
    @property
    def closed(self):
        return self.data[0].closed
    @closed.setter
    def closed(self, value):
        self.data[0].closed = value
    @property
    def time_offset(self):
        return self.data[0].time_offset
    @time_offset.setter
    def time_offset(self, value):
        self.data[0].time_offset = value
    @property
    def something8(self):
        return self.data[0].something8
    @something8.setter
    def something8(self, value):
        self.data[0].something8 = value
    @property
    def user_id(self):
        return self.data[0].user_id
    @user_id.setter
    def user_id(self, value):
        self.data[0].user_id = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, StaticEntityHeader * ptr):
        self.data = ptr
    cdef void _set_ptr(self, StaticEntityHeader * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._size is not None:
            set_array_base(self._size, self.holder)
            self._size.data = <char*>&self.data[0].size
    def set_ptr(self, WrapStaticEntityHeader v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapStaticEntity:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(StaticEntity))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(StaticEntity))
    def cast(self, object klass):
        cdef WrapStaticEntity c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapStaticEntity inst = WrapStaticEntity.__new__(WrapStaticEntity)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(StaticEntity))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef StaticEntity * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(StaticEntity))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(StaticEntity))
            return
        cdef StaticEntity * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(StaticEntity))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntity))
        self._set_ptr(<StaticEntity*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntity))
        self._init_ptr(<StaticEntity*>buf)
    @property
    def header(self):
        if self._header is not None:
            return self._header
        self._header = WrapStaticEntityHeader.__new__(WrapStaticEntityHeader)
        self._header.holder = self.holder
        self._header._init_ptr(&self.data[0].header)
        return self._header
    @header.setter
    def header(self, value):
        cdef WrapStaticEntityHeader v = value
        self.data[0].header = v.data[0]
    @property
    def item_with_header_lists(self):
        if self._item_with_header_lists is not None:
            return self._item_with_header_lists
        self._item_with_header_lists = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        self._item_with_header_lists.holder = self.holder
        self._item_with_header_lists._init_ptr(&self.data[0].item_with_header_lists)
        return self._item_with_header_lists
    @item_with_header_lists.setter
    def item_with_header_lists(self, value):
        cdef WrapItemWithHeaderLists v = value
        self.data[0].item_with_header_lists = v.data[0]
    @property
    def something1(self):
        return self.data[0].something1
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def item(self):
        if self._item is not None:
            return self._item
        self._item = WrapItemData.__new__(WrapItemData)
        self._item.holder = self.holder
        self._item._init_ptr(&self.data[0].item)
        return self._item
    @item.setter
    def item(self, value):
        cdef WrapItemData v = value
        self.data[0].item = v.data[0]
    @property
    def something2(self):
        return self.data[0].something2
    @something2.setter
    def something2(self, value):
        self.data[0].something2 = value
    @property
    def something3(self):
        return self.data[0].something3
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def something4(self):
        return self.data[0].something4
    @something4.setter
    def something4(self, value):
        self.data[0].something4 = value
    @property
    def something5(self):
        return self.data[0].something5
    @something5.setter
    def something5(self, value):
        self.data[0].something5 = value
    @property
    def something6(self):
        return self.data[0].something6
    @something6.setter
    def something6(self, value):
        self.data[0].something6 = value
    @property
    def something7(self):
        return self.data[0].something7
    @something7.setter
    def something7(self, value):
        self.data[0].something7 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, StaticEntity * ptr):
        self.data = ptr
    cdef void _set_ptr(self, StaticEntity * ptr):
        self.data = ptr
        if self._header is not None:
            self._header.holder = self.holder
            self._header._set_ptr(&self.data[0].header)
        if self._item_with_header_lists is not None:
            self._item_with_header_lists.holder = self.holder
            self._item_with_header_lists._set_ptr(&self.data[0].item_with_header_lists)
        if self._item is not None:
            self._item.holder = self.holder
            self._item._set_ptr(&self.data[0].item)
    def set_ptr(self, WrapStaticEntity v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItemWithExtra:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithExtra))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithExtra))
    def cast(self, object klass):
        cdef WrapItemWithExtra c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItemWithExtra inst = WrapItemWithExtra.__new__(WrapItemWithExtra)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithExtra))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ItemWithExtra * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ItemWithExtra))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ItemWithExtra))
            return
        cdef ItemWithExtra * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ItemWithExtra))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithExtra))
        self._set_ptr(<ItemWithExtra*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ItemWithExtra))
        self._init_ptr(<ItemWithExtra*>buf)
    @property
    def lists(self):
        if self._lists is not None:
            return self._lists
        self._lists = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        self._lists.holder = self.holder
        self._lists._init_ptr(&self.data[0].lists)
        return self._lists
    @lists.setter
    def lists(self, value):
        cdef WrapItemWithHeaderLists v = value
        self.data[0].lists = v.data[0]
    @property
    def something1(self):
        return self.data[0].something1
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def item(self):
        if self._item is not None:
            return self._item
        self._item = WrapItemData.__new__(WrapItemData)
        self._item.holder = self.holder
        self._item._init_ptr(&self.data[0].item)
        return self._item
    @item.setter
    def item(self, value):
        cdef WrapItemData v = value
        self.data[0].item = v.data[0]
    @property
    def something_added1(self):
        return self.data[0].something_added1
    @something_added1.setter
    def something_added1(self, value):
        self.data[0].something_added1 = value
    @property
    def something_added2(self):
        return self.data[0].something_added2
    @something_added2.setter
    def something_added2(self, value):
        self.data[0].something_added2 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ItemWithExtra * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ItemWithExtra * ptr):
        self.data = ptr
        if self._lists is not None:
            self._lists.holder = self.holder
            self._lists._set_ptr(&self.data[0].lists)
        if self._item is not None:
            self._item.holder = self.holder
            self._item._set_ptr(&self.data[0].item)
    def set_ptr(self, WrapItemWithExtra v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapSpawn:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Spawn))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Spawn))
    def cast(self, object klass):
        cdef WrapSpawn c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapSpawn inst = WrapSpawn.__new__(WrapSpawn)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Spawn))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Spawn * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Spawn))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Spawn))
            return
        cdef Spawn * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Spawn))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Spawn))
        self._set_ptr(<Spawn*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Spawn))
        self._init_ptr(<Spawn*>buf)
    @property
    def vtable(self):
        return self.data[0].vtable
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def something1(self):
        return self.data[0].something1
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def something2(self):
        if self._something2 is not None:
            return self._something2
        self._something2 = <int8_t[:4]>(&self.data[0].something2[0])
        return self._something2
    @something2.setter
    def something2(self, value):
        raise NotImplementedError()
    @property
    def x(self):
        return self.data[0].x
    @x.setter
    def x(self, value):
        self.data[0].x = value
    @property
    def y(self):
        return self.data[0].y
    @y.setter
    def y(self, value):
        self.data[0].y = value
    @property
    def z(self):
        return self.data[0].z
    @z.setter
    def z(self, value):
        self.data[0].z = value
    @property
    def hostile_type(self):
        return self.data[0].hostile_type
    @hostile_type.setter
    def hostile_type(self, value):
        self.data[0].hostile_type = value
    @property
    def something3(self):
        if self._something3 is not None:
            return self._something3
        self._something3 = <int8_t[:3]>(&self.data[0].something3[0])
        return self._something3
    @something3.setter
    def something3(self, value):
        raise NotImplementedError()
    @property
    def entity_type(self):
        return self.data[0].entity_type
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def class_type(self):
        return self.data[0].class_type
    @class_type.setter
    def class_type(self, value):
        self.data[0].class_type = value
    @property
    def specialization(self):
        return self.data[0].specialization
    @specialization.setter
    def specialization(self, value):
        self.data[0].specialization = value
    @property
    def level(self):
        return self.data[0].level
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def something33(self):
        return self.data[0].something33
    @something33.setter
    def something33(self, value):
        self.data[0].something33 = value
    @property
    def something34(self):
        return self.data[0].something34
    @something34.setter
    def something34(self, value):
        self.data[0].something34 = value
    @property
    def something35(self):
        return self.data[0].something35
    @something35.setter
    def something35(self, value):
        self.data[0].something35 = value
    @property
    def something36(self):
        return self.data[0].something36
    @something36.setter
    def something36(self, value):
        self.data[0].something36 = value
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def enable_flag_8_flags_1(self):
        return self.data[0].enable_flag_8_flags_1
    @enable_flag_8_flags_1.setter
    def enable_flag_8_flags_1(self, value):
        self.data[0].enable_flag_8_flags_1 = value
    @property
    def body_yaw(self):
        return self.data[0].body_yaw
    @body_yaw.setter
    def body_yaw(self, value):
        self.data[0].body_yaw = value
    @property
    def power_base(self):
        return self.data[0].power_base
    @power_base.setter
    def power_base(self, value):
        self.data[0].power_base = value
    @property
    def not_used19(self):
        return self.data[0].not_used19
    @not_used19.setter
    def not_used19(self, value):
        self.data[0].not_used19 = value
    @property
    def not_used20(self):
        return self.data[0].not_used20
    @not_used20.setter
    def not_used20(self, value):
        self.data[0].not_used20 = value
    @property
    def not_used21(self):
        return self.data[0].not_used21
    @not_used21.setter
    def not_used21(self, value):
        self.data[0].not_used21 = value
    @property
    def not_used22(self):
        return self.data[0].not_used22
    @not_used22.setter
    def not_used22(self, value):
        self.data[0].not_used22 = value
    @property
    def something14(self):
        return self.data[0].something14
    @something14.setter
    def something14(self, value):
        self.data[0].something14 = value
    @property
    def something15(self):
        return self.data[0].something15
    @something15.setter
    def something15(self, value):
        self.data[0].something15 = value
    @property
    def appearance(self):
        if self._appearance is not None:
            return self._appearance
        self._appearance = WrapAppearanceData.__new__(WrapAppearanceData)
        self._appearance.holder = self.holder
        self._appearance._init_ptr(&self.data[0].appearance)
        return self._appearance
    @appearance.setter
    def appearance(self, value):
        cdef WrapAppearanceData v = value
        self.data[0].appearance = v.data[0]
    @property
    def items(self):
        if self._items is not None:
            return self._items
        self._items = WrapArray1.__new__(WrapArray1)
        self._items.holder = self.holder
        self._items._init_ptr(&self.data[0].items[0])
        return self._items
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def max_hp_multiplier(self):
        return self.data[0].max_hp_multiplier
    @max_hp_multiplier.setter
    def max_hp_multiplier(self, value):
        self.data[0].max_hp_multiplier = value
    @property
    def shoot_speed(self):
        return self.data[0].shoot_speed
    @shoot_speed.setter
    def shoot_speed(self, value):
        self.data[0].shoot_speed = value
    @property
    def damage_multiplier(self):
        return self.data[0].damage_multiplier
    @damage_multiplier.setter
    def damage_multiplier(self, value):
        self.data[0].damage_multiplier = value
    @property
    def armor_multiplier(self):
        return self.data[0].armor_multiplier
    @armor_multiplier.setter
    def armor_multiplier(self, value):
        self.data[0].armor_multiplier = value
    @property
    def resi_multiplier(self):
        return self.data[0].resi_multiplier
    @resi_multiplier.setter
    def resi_multiplier(self, value):
        self.data[0].resi_multiplier = value
    @property
    def extra_item(self):
        if self._extra_item is not None:
            return self._extra_item
        self._extra_item = WrapItemWithExtra.__new__(WrapItemWithExtra)
        self._extra_item.holder = self.holder
        self._extra_item._init_ptr(&self.data[0].extra_item)
        return self._extra_item
    @extra_item.setter
    def extra_item(self, value):
        cdef WrapItemWithExtra v = value
        self.data[0].extra_item = v.data[0]
    @property
    def some_12b_p(self):
        return self.data[0].some_12b_p
    @some_12b_p.setter
    def some_12b_p(self, value):
        self.data[0].some_12b_p = value
    @property
    def some_vec(self):
        if self._some_vec is not None:
            return self._some_vec
        self._some_vec = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some_vec.holder = self.holder
        self._some_vec._init_ptr(&self.data[0].some_vec_start)
        return self._some_vec
    @some_vec.setter
    def some_vec(self, value):
        raise NotImplementedError()
    @property
    def id_vec_1(self):
        if self._id_vec_1 is not None:
            return self._id_vec_1
        self._id_vec_1 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._id_vec_1.holder = self.holder
        self._id_vec_1._init_ptr(&self.data[0].id_vec_1_start)
        return self._id_vec_1
    @id_vec_1.setter
    def id_vec_1(self, value):
        raise NotImplementedError()
    @property
    def id_vec_2_end_old(self):
        return self.data[0].id_vec_2_end_old
    @id_vec_2_end_old.setter
    def id_vec_2_end_old(self, value):
        self.data[0].id_vec_2_end_old = value
    @property
    def id_vec_2(self):
        if self._id_vec_2 is not None:
            return self._id_vec_2
        self._id_vec_2 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._id_vec_2.holder = self.holder
        self._id_vec_2._init_ptr(&self.data[0].id_vec_2_start)
        return self._id_vec_2
    @id_vec_2.setter
    def id_vec_2(self, value):
        raise NotImplementedError()
    @property
    def unknown_or_not_used4(self):
        return self.data[0].unknown_or_not_used4
    @unknown_or_not_used4.setter
    def unknown_or_not_used4(self, value):
        self.data[0].unknown_or_not_used4 = value
    @property
    def name(self):
        cdef int i = 0
        while i < 16:
            if self.data[0].name[i] == 0: break
            i += 1
        return filter_bytes(self.data[0].name[:i])
    @name.setter
    def name(self, value):
        cdef str v = value
        cdef bytes vv = v.encode('ascii', 'ignore')[:16]
        cdef const char * c = vv
        cdef size_t size = len(vv)
        cdef int i
        for i in range(16):
            if i >= size:
                self.data[0].name[i] = 0
            else:
                self.data[0].name[i] = c[i]
    @property
    def something30(self):
        return self.data[0].something30
    @something30.setter
    def something30(self, value):
        self.data[0].something30 = value
    @property
    def something31(self):
        return self.data[0].something31
    @something31.setter
    def something31(self, value):
        self.data[0].something31 = value
    @property
    def something32(self):
        return self.data[0].something32
    @something32.setter
    def something32(self, value):
        self.data[0].something32 = value
    @property
    def something37(self):
        return self.data[0].something37
    @something37.setter
    def something37(self, value):
        self.data[0].something37 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Spawn * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Spawn * ptr):
        self.data = ptr
        if self._something2 is not None:
            self._something2.data = <char*>(&self.data[0].something2[0])
        if self._something3 is not None:
            self._something3.data = <char*>(&self.data[0].something3[0])
        if self._appearance is not None:
            self._appearance.holder = self.holder
            self._appearance._set_ptr(&self.data[0].appearance)
        if self._items is not None:
            self._items.holder = self.holder
            self._items._set_ptr(&self.data[0].items[0])
        if self._extra_item is not None:
            self._extra_item.holder = self.holder
            self._extra_item._set_ptr(&self.data[0].extra_item)
        if self._some_vec is not None:
            self._some_vec.holder = self.holder
            self._some_vec._set_ptr(&self.data[0].some_vec_start)
        if self._id_vec_1 is not None:
            self._id_vec_1.holder = self.holder
            self._id_vec_1._set_ptr(&self.data[0].id_vec_1_start)
        if self._id_vec_2 is not None:
            self._id_vec_2.holder = self.holder
            self._id_vec_2._set_ptr(&self.data[0].id_vec_2_start)
    def set_ptr(self, WrapSpawn v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapCriticalSection:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(CriticalSection))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(CriticalSection))
    def cast(self, object klass):
        cdef WrapCriticalSection c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapCriticalSection inst = WrapCriticalSection.__new__(WrapCriticalSection)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(CriticalSection))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef CriticalSection * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(CriticalSection))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(CriticalSection))
            return
        cdef CriticalSection * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(CriticalSection))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(CriticalSection))
        self._set_ptr(<CriticalSection*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(CriticalSection))
        self._init_ptr(<CriticalSection*>buf)
    @property
    def DebugInfo(self):
        if self.data[0].DebugInfo == 0:
            return None
        if self._DebugInfo is not None:
            return self._DebugInfo
        self._DebugInfo = WrapArray2.__new__(WrapArray2)
        self._DebugInfo.holder = self.holder
        self._DebugInfo._init_ptr(&(<int8_t*>self.data[0].DebugInfo)[0])
        return self._DebugInfo
    @DebugInfo.setter
    def DebugInfo(self, value):
        raise NotImplementedError()
    @property
    def LockCount(self):
        return self.data[0].LockCount
    @LockCount.setter
    def LockCount(self, value):
        self.data[0].LockCount = value
    @property
    def RecursionCount(self):
        return self.data[0].RecursionCount
    @RecursionCount.setter
    def RecursionCount(self, value):
        self.data[0].RecursionCount = value
    @property
    def OwningThread(self):
        return self.data[0].OwningThread
    @OwningThread.setter
    def OwningThread(self, value):
        self.data[0].OwningThread = value
    @property
    def LockSemaphore(self):
        return self.data[0].LockSemaphore
    @LockSemaphore.setter
    def LockSemaphore(self, value):
        self.data[0].LockSemaphore = value
    @property
    def SpinCount(self):
        return self.data[0].SpinCount
    @SpinCount.setter
    def SpinCount(self, value):
        self.data[0].SpinCount = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, CriticalSection * ptr):
        self.data = ptr
    cdef void _set_ptr(self, CriticalSection * ptr):
        self.data = ptr
        if self._DebugInfo is not None:
            self._DebugInfo.holder = self.holder
            self._DebugInfo._set_ptr(&(<int8_t*>self.data[0].DebugInfo)[0])
    def set_ptr(self, WrapCriticalSection v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapColor:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Color))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Color))
    def cast(self, object klass):
        cdef WrapColor c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapColor inst = WrapColor.__new__(WrapColor)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Color))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Color * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Color))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Color))
            return
        cdef Color * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Color))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Color))
        self._set_ptr(<Color*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Color))
        self._init_ptr(<Color*>buf)
    @property
    def r(self):
        return self.data[0].r
    @r.setter
    def r(self, value):
        self.data[0].r = value
    @property
    def g(self):
        return self.data[0].g
    @g.setter
    def g(self, value):
        self.data[0].g = value
    @property
    def b(self):
        return self.data[0].b
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def a(self):
        return self.data[0].a
    @a.setter
    def a(self, value):
        self.data[0].a = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Color * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Color * ptr):
        self.data = ptr
    def set_ptr(self, WrapColor v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapField:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Field))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Field))
    def cast(self, object klass):
        cdef WrapField c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapField inst = WrapField.__new__(WrapField)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Field))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Field * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Field))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Field))
            return
        cdef Field * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Field))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Field))
        self._set_ptr(<Field*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Field))
        self._init_ptr(<Field*>buf)
    @property
    def vtable(self):
        return self.data[0].vtable
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def f1(self):
        return self.data[0].f1
    @f1.setter
    def f1(self, value):
        self.data[0].f1 = value
    @property
    def f2(self):
        return self.data[0].f2
    @f2.setter
    def f2(self, value):
        self.data[0].f2 = value
    @property
    def f3(self):
        return self.data[0].f3
    @f3.setter
    def f3(self, value):
        self.data[0].f3 = value
    @property
    def a(self):
        return self.data[0].a
    @a.setter
    def a(self, value):
        self.data[0].a = value
    @property
    def b(self):
        return self.data[0].b
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def data(self):
        if self.data[0].data == 0:
            return None
        if self._data is not None:
            return self._data
        self._data = WrapArray3.__new__(WrapArray3)
        self._data.holder = self.holder
        self._data._init_ptr(&(<Color*>self.data[0].data)[0])
        return self._data
    @data.setter
    def data(self, value):
        raise NotImplementedError()
    @property
    def size(self):
        return self.data[0].size
    @size.setter
    def size(self, value):
        self.data[0].size = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Field * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Field * ptr):
        self.data = ptr
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&(<Color*>self.data[0].data)[0])
    def set_ptr(self, WrapField v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapChunkItemData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ChunkItemData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ChunkItemData))
    def cast(self, object klass):
        cdef WrapChunkItemData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapChunkItemData inst = WrapChunkItemData.__new__(WrapChunkItemData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ChunkItemData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ChunkItemData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ChunkItemData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ChunkItemData))
            return
        cdef ChunkItemData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ChunkItemData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemData))
        self._set_ptr(<ChunkItemData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemData))
        self._init_ptr(<ChunkItemData*>buf)
    @property
    def item_data(self):
        if self._item_data is not None:
            return self._item_data
        self._item_data = WrapItemData.__new__(WrapItemData)
        self._item_data.holder = self.holder
        self._item_data._init_ptr(&self.data[0].item_data)
        return self._item_data
    @item_data.setter
    def item_data(self, value):
        cdef WrapItemData v = value
        self.data[0].item_data = v.data[0]
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def rotation(self):
        return self.data[0].rotation
    @rotation.setter
    def rotation(self, value):
        self.data[0].rotation = value
    @property
    def scale(self):
        return self.data[0].scale
    @scale.setter
    def scale(self, value):
        self.data[0].scale = value
    @property
    def something3(self):
        return self.data[0].something3
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def drop_time(self):
        return self.data[0].drop_time
    @drop_time.setter
    def drop_time(self, value):
        self.data[0].drop_time = value
    @property
    def something5(self):
        return self.data[0].something5
    @something5.setter
    def something5(self, value):
        self.data[0].something5 = value
    @property
    def something6(self):
        return self.data[0].something6
    @something6.setter
    def something6(self, value):
        self.data[0].something6 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ChunkItemData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ChunkItemData * ptr):
        self.data = ptr
        if self._item_data is not None:
            self._item_data.holder = self.holder
            self._item_data._set_ptr(&self.data[0].item_data)
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
    def set_ptr(self, WrapChunkItemData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapZone:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Zone))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Zone))
    def cast(self, object klass):
        cdef WrapZone c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapZone inst = WrapZone.__new__(WrapZone)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Zone))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Zone * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Zone))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Zone))
            return
        cdef Zone * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Zone))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Zone))
        self._set_ptr(<Zone*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Zone))
        self._init_ptr(<Zone*>buf)
    @property
    def vtable(self):
        return self.data[0].vtable
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def b(self):
        return self.data[0].b
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def c(self):
        return self.data[0].c
    @c.setter
    def c(self, value):
        self.data[0].c = value
    @property
    def static_entities(self):
        if self._static_entities is not None:
            return self._static_entities
        self._static_entities = WrapStaticEntityVec.__new__(WrapStaticEntityVec)
        self._static_entities.holder = self.holder
        self._static_entities._init_ptr(&self.data[0].static_entities_start)
        return self._static_entities
    @static_entities.setter
    def static_entities(self, value):
        raise NotImplementedError()
    @property
    def spawns(self):
        if self._spawns is not None:
            return self._spawns
        self._spawns = WrapSpawnPtrVec.__new__(WrapSpawnPtrVec)
        self._spawns.holder = self.holder
        self._spawns._init_ptr(&self.data[0].spawns_start)
        return self._spawns
    @spawns.setter
    def spawns(self, value):
        raise NotImplementedError()
    @property
    def some4(self):
        if self._some4 is not None:
            return self._some4
        self._some4 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some4.holder = self.holder
        self._some4._init_ptr(&self.data[0].some4_start)
        return self._some4
    @some4.setter
    def some4(self, value):
        raise NotImplementedError()
    @property
    def items(self):
        if self._items is not None:
            return self._items
        self._items = WrapChunkItemDataVec.__new__(WrapChunkItemDataVec)
        self._items.holder = self.holder
        self._items._init_ptr(&self.data[0].items_start)
        return self._items
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def some9(self):
        if self._some9 is not None:
            return self._some9
        self._some9 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some9.holder = self.holder
        self._some9._init_ptr(&self.data[0].some9_start)
        return self._some9
    @some9.setter
    def some9(self, value):
        raise NotImplementedError()
    @property
    def some8(self):
        if self._some8 is not None:
            return self._some8
        self._some8 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some8.holder = self.holder
        self._some8._init_ptr(&self.data[0].some8_start)
        return self._some8
    @some8.setter
    def some8(self, value):
        raise NotImplementedError()
    @property
    def some7(self):
        if self._some7 is not None:
            return self._some7
        self._some7 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some7.holder = self.holder
        self._some7._init_ptr(&self.data[0].some7_start)
        return self._some7
    @some7.setter
    def some7(self, value):
        raise NotImplementedError()
    @property
    def chunk_x(self):
        return self.data[0].chunk_x
    @chunk_x.setter
    def chunk_x(self, value):
        self.data[0].chunk_x = value
    @property
    def chunk_y(self):
        return self.data[0].chunk_y
    @chunk_y.setter
    def chunk_y(self, value):
        self.data[0].chunk_y = value
    @property
    def some2_20byte(self):
        if self._some2_20byte is not None:
            return self._some2_20byte
        self._some2_20byte = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some2_20byte.holder = self.holder
        self._some2_20byte._init_ptr(&self.data[0].some2_20byte_start)
        return self._some2_20byte
    @some2_20byte.setter
    def some2_20byte(self, value):
        raise NotImplementedError()
    @property
    def word74(self):
        return self.data[0].word74
    @word74.setter
    def word74(self, value):
        self.data[0].word74 = value
    @property
    def has_chunkitems(self):
        return self.data[0].has_chunkitems
    @has_chunkitems.setter
    def has_chunkitems(self, value):
        self.data[0].has_chunkitems = value
    @property
    def byte76(self):
        return self.data[0].byte76
    @byte76.setter
    def byte76(self, value):
        self.data[0].byte76 = value
    @property
    def dword78(self):
        return self.data[0].dword78
    @dword78.setter
    def dword78(self, value):
        self.data[0].dword78 = value
    @property
    def dword7C(self):
        return self.data[0].dword7C
    @dword7C.setter
    def dword7C(self, value):
        self.data[0].dword7C = value
    @property
    def dword80(self):
        return self.data[0].dword80
    @dword80.setter
    def dword80(self, value):
        self.data[0].dword80 = value
    @property
    def byte84(self):
        return self.data[0].byte84
    @byte84.setter
    def byte84(self, value):
        self.data[0].byte84 = value
    @property
    def some5(self):
        if self._some5 is not None:
            return self._some5
        self._some5 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some5.holder = self.holder
        self._some5._init_ptr(&self.data[0].some5_start)
        return self._some5
    @some5.setter
    def some5(self, value):
        raise NotImplementedError()
    @property
    def some6(self):
        if self._some6 is not None:
            return self._some6
        self._some6 = Wrapuint8Vec.__new__(Wrapuint8Vec)
        self._some6.holder = self.holder
        self._some6._init_ptr(&self.data[0].some6_start)
        return self._some6
    @some6.setter
    def some6(self, value):
        raise NotImplementedError()
    @property
    def start_something_dynamic_entities(self):
        return self.data[0].start_something_dynamic_entities
    @start_something_dynamic_entities.setter
    def start_something_dynamic_entities(self, value):
        self.data[0].start_something_dynamic_entities = value
    @property
    def dwordA4(self):
        return self.data[0].dwordA4
    @dwordA4.setter
    def dwordA4(self, value):
        self.data[0].dwordA4 = value
    @property
    def fields(self):
        if self.data[0].fields == 0:
            return None
        if self._fields is not None:
            return self._fields
        self._fields = WrapArray4.__new__(WrapArray4)
        self._fields.holder = self.holder
        self._fields._init_ptr(&(<Field*>self.data[0].fields)[0])
        return self._fields
    @fields.setter
    def fields(self, value):
        raise NotImplementedError()
    @property
    def other_chunk_data(self):
        return self.data[0].other_chunk_data
    @other_chunk_data.setter
    def other_chunk_data(self, value):
        self.data[0].other_chunk_data = value
    @property
    def crit_sec(self):
        if self._crit_sec is not None:
            return self._crit_sec
        self._crit_sec = WrapCriticalSection.__new__(WrapCriticalSection)
        self._crit_sec.holder = self.holder
        self._crit_sec._init_ptr(&self.data[0].crit_sec)
        return self._crit_sec
    @crit_sec.setter
    def crit_sec(self, value):
        cdef WrapCriticalSection v = value
        self.data[0].crit_sec = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Zone * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Zone * ptr):
        self.data = ptr
        if self._static_entities is not None:
            self._static_entities.holder = self.holder
            self._static_entities._set_ptr(&self.data[0].static_entities_start)
        if self._spawns is not None:
            self._spawns.holder = self.holder
            self._spawns._set_ptr(&self.data[0].spawns_start)
        if self._some4 is not None:
            self._some4.holder = self.holder
            self._some4._set_ptr(&self.data[0].some4_start)
        if self._items is not None:
            self._items.holder = self.holder
            self._items._set_ptr(&self.data[0].items_start)
        if self._some9 is not None:
            self._some9.holder = self.holder
            self._some9._set_ptr(&self.data[0].some9_start)
        if self._some8 is not None:
            self._some8.holder = self.holder
            self._some8._set_ptr(&self.data[0].some8_start)
        if self._some7 is not None:
            self._some7.holder = self.holder
            self._some7._set_ptr(&self.data[0].some7_start)
        if self._some2_20byte is not None:
            self._some2_20byte.holder = self.holder
            self._some2_20byte._set_ptr(&self.data[0].some2_20byte_start)
        if self._some5 is not None:
            self._some5.holder = self.holder
            self._some5._set_ptr(&self.data[0].some5_start)
        if self._some6 is not None:
            self._some6.holder = self.holder
            self._some6._set_ptr(&self.data[0].some6_start)
        if self._fields is not None:
            self._fields.holder = self.holder
            self._fields._set_ptr(&(<Field*>self.data[0].fields)[0])
        if self._crit_sec is not None:
            self._crit_sec.holder = self.holder
            self._crit_sec._set_ptr(&self.data[0].crit_sec)
    def set_ptr(self, WrapZone v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapSomethingCreature:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(SomethingCreature))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(SomethingCreature))
    def cast(self, object klass):
        cdef WrapSomethingCreature c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapSomethingCreature inst = WrapSomethingCreature.__new__(WrapSomethingCreature)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(SomethingCreature))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef SomethingCreature * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(SomethingCreature))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(SomethingCreature))
            return
        cdef SomethingCreature * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(SomethingCreature))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SomethingCreature))
        self._set_ptr(<SomethingCreature*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SomethingCreature))
        self._init_ptr(<SomethingCreature*>buf)
    @property
    def dword0(self):
        return self.data[0].dword0
    @dword0.setter
    def dword0(self, value):
        self.data[0].dword0 = value
    @property
    def dword4(self):
        return self.data[0].dword4
    @dword4.setter
    def dword4(self, value):
        self.data[0].dword4 = value
    @property
    def dword8(self):
        return self.data[0].dword8
    @dword8.setter
    def dword8(self, value):
        self.data[0].dword8 = value
    @property
    def dwordC(self):
        return self.data[0].dwordC
    @dwordC.setter
    def dwordC(self, value):
        self.data[0].dwordC = value
    @property
    def dword10(self):
        return self.data[0].dword10
    @dword10.setter
    def dword10(self, value):
        self.data[0].dword10 = value
    @property
    def dword14(self):
        return self.data[0].dword14
    @dword14.setter
    def dword14(self, value):
        self.data[0].dword14 = value
    @property
    def dword18(self):
        return self.data[0].dword18
    @dword18.setter
    def dword18(self, value):
        self.data[0].dword18 = value
    @property
    def dword1C(self):
        return self.data[0].dword1C
    @dword1C.setter
    def dword1C(self, value):
        self.data[0].dword1C = value
    @property
    def dword20(self):
        return self.data[0].dword20
    @dword20.setter
    def dword20(self, value):
        self.data[0].dword20 = value
    @property
    def dword24(self):
        return self.data[0].dword24
    @dword24.setter
    def dword24(self, value):
        self.data[0].dword24 = value
    @property
    def dword28(self):
        return self.data[0].dword28
    @dword28.setter
    def dword28(self, value):
        self.data[0].dword28 = value
    @property
    def dword2C(self):
        return self.data[0].dword2C
    @dword2C.setter
    def dword2C(self, value):
        self.data[0].dword2C = value
    @property
    def dword30(self):
        return self.data[0].dword30
    @dword30.setter
    def dword30(self, value):
        self.data[0].dword30 = value
    @property
    def dword34(self):
        return self.data[0].dword34
    @dword34.setter
    def dword34(self, value):
        self.data[0].dword34 = value
    @property
    def dword38(self):
        return self.data[0].dword38
    @dword38.setter
    def dword38(self, value):
        self.data[0].dword38 = value
    @property
    def dword3C(self):
        return self.data[0].dword3C
    @dword3C.setter
    def dword3C(self, value):
        self.data[0].dword3C = value
    @property
    def dword40(self):
        return self.data[0].dword40
    @dword40.setter
    def dword40(self, value):
        self.data[0].dword40 = value
    @property
    def dword44(self):
        return self.data[0].dword44
    @dword44.setter
    def dword44(self, value):
        self.data[0].dword44 = value
    @property
    def dword48(self):
        return self.data[0].dword48
    @dword48.setter
    def dword48(self, value):
        self.data[0].dword48 = value
    @property
    def dword4C(self):
        return self.data[0].dword4C
    @dword4C.setter
    def dword4C(self, value):
        self.data[0].dword4C = value
    @property
    def dword50(self):
        return self.data[0].dword50
    @dword50.setter
    def dword50(self, value):
        self.data[0].dword50 = value
    @property
    def dword54(self):
        return self.data[0].dword54
    @dword54.setter
    def dword54(self, value):
        self.data[0].dword54 = value
    @property
    def dword58(self):
        return self.data[0].dword58
    @dword58.setter
    def dword58(self, value):
        self.data[0].dword58 = value
    @property
    def dword5C(self):
        return self.data[0].dword5C
    @dword5C.setter
    def dword5C(self, value):
        self.data[0].dword5C = value
    @property
    def dword60(self):
        return self.data[0].dword60
    @dword60.setter
    def dword60(self, value):
        self.data[0].dword60 = value
    @property
    def dword64(self):
        return self.data[0].dword64
    @dword64.setter
    def dword64(self, value):
        self.data[0].dword64 = value
    @property
    def dword68(self):
        return self.data[0].dword68
    @dword68.setter
    def dword68(self, value):
        self.data[0].dword68 = value
    @property
    def dword6C(self):
        return self.data[0].dword6C
    @dword6C.setter
    def dword6C(self, value):
        self.data[0].dword6C = value
    @property
    def dword70(self):
        return self.data[0].dword70
    @dword70.setter
    def dword70(self, value):
        self.data[0].dword70 = value
    @property
    def dword74(self):
        return self.data[0].dword74
    @dword74.setter
    def dword74(self, value):
        self.data[0].dword74 = value
    @property
    def dword78(self):
        return self.data[0].dword78
    @dword78.setter
    def dword78(self, value):
        self.data[0].dword78 = value
    @property
    def dword7C(self):
        return self.data[0].dword7C
    @dword7C.setter
    def dword7C(self, value):
        self.data[0].dword7C = value
    @property
    def dword80(self):
        return self.data[0].dword80
    @dword80.setter
    def dword80(self, value):
        self.data[0].dword80 = value
    @property
    def dword84(self):
        return self.data[0].dword84
    @dword84.setter
    def dword84(self, value):
        self.data[0].dword84 = value
    @property
    def dword88(self):
        return self.data[0].dword88
    @dword88.setter
    def dword88(self, value):
        self.data[0].dword88 = value
    @property
    def dword8C(self):
        return self.data[0].dword8C
    @dword8C.setter
    def dword8C(self, value):
        self.data[0].dword8C = value
    @property
    def dword90(self):
        return self.data[0].dword90
    @dword90.setter
    def dword90(self, value):
        self.data[0].dword90 = value
    @property
    def dword94(self):
        return self.data[0].dword94
    @dword94.setter
    def dword94(self, value):
        self.data[0].dword94 = value
    @property
    def dword98(self):
        return self.data[0].dword98
    @dword98.setter
    def dword98(self, value):
        self.data[0].dword98 = value
    @property
    def dword9C(self):
        return self.data[0].dword9C
    @dword9C.setter
    def dword9C(self, value):
        self.data[0].dword9C = value
    @property
    def dwordA0(self):
        return self.data[0].dwordA0
    @dwordA0.setter
    def dwordA0(self, value):
        self.data[0].dwordA0 = value
    @property
    def dwordA4(self):
        return self.data[0].dwordA4
    @dwordA4.setter
    def dwordA4(self, value):
        self.data[0].dwordA4 = value
    @property
    def dwordA8(self):
        return self.data[0].dwordA8
    @dwordA8.setter
    def dwordA8(self, value):
        self.data[0].dwordA8 = value
    @property
    def dwordAC(self):
        return self.data[0].dwordAC
    @dwordAC.setter
    def dwordAC(self, value):
        self.data[0].dwordAC = value
    @property
    def dwordB0(self):
        return self.data[0].dwordB0
    @dwordB0.setter
    def dwordB0(self, value):
        self.data[0].dwordB0 = value
    @property
    def dwordB4(self):
        return self.data[0].dwordB4
    @dwordB4.setter
    def dwordB4(self, value):
        self.data[0].dwordB4 = value
    @property
    def dwordB8(self):
        return self.data[0].dwordB8
    @dwordB8.setter
    def dwordB8(self, value):
        self.data[0].dwordB8 = value
    @property
    def dwordBC(self):
        return self.data[0].dwordBC
    @dwordBC.setter
    def dwordBC(self, value):
        self.data[0].dwordBC = value
    @property
    def dwordC4(self):
        return self.data[0].dwordC4
    @dwordC4.setter
    def dwordC4(self, value):
        self.data[0].dwordC4 = value
    @property
    def dwordC8(self):
        return self.data[0].dwordC8
    @dwordC8.setter
    def dwordC8(self, value):
        self.data[0].dwordC8 = value
    @property
    def dwordCC(self):
        return self.data[0].dwordCC
    @dwordCC.setter
    def dwordCC(self, value):
        self.data[0].dwordCC = value
    @property
    def dwordD0(self):
        return self.data[0].dwordD0
    @dwordD0.setter
    def dwordD0(self, value):
        self.data[0].dwordD0 = value
    @property
    def dwordD4(self):
        return self.data[0].dwordD4
    @dwordD4.setter
    def dwordD4(self, value):
        self.data[0].dwordD4 = value
    @property
    def dwordD8(self):
        return self.data[0].dwordD8
    @dwordD8.setter
    def dwordD8(self, value):
        self.data[0].dwordD8 = value
    @property
    def dwordDC(self):
        return self.data[0].dwordDC
    @dwordDC.setter
    def dwordDC(self, value):
        self.data[0].dwordDC = value
    @property
    def dwordE4(self):
        return self.data[0].dwordE4
    @dwordE4.setter
    def dwordE4(self, value):
        self.data[0].dwordE4 = value
    @property
    def dwordE8(self):
        return self.data[0].dwordE8
    @dwordE8.setter
    def dwordE8(self, value):
        self.data[0].dwordE8 = value
    @property
    def dword86C(self):
        return self.data[0].dword86C
    @dword86C.setter
    def dword86C(self, value):
        self.data[0].dword86C = value
    @property
    def dword870(self):
        return self.data[0].dword870
    @dword870.setter
    def dword870(self, value):
        self.data[0].dword870 = value
    @property
    def dword874(self):
        return self.data[0].dword874
    @dword874.setter
    def dword874(self, value):
        self.data[0].dword874 = value
    @property
    def byte878(self):
        return self.data[0].byte878
    @byte878.setter
    def byte878(self, value):
        self.data[0].byte878 = value
    @property
    def dword880(self):
        return self.data[0].dword880
    @dword880.setter
    def dword880(self, value):
        self.data[0].dword880 = value
    @property
    def dword884(self):
        return self.data[0].dword884
    @dword884.setter
    def dword884(self, value):
        self.data[0].dword884 = value
    @property
    def dword888(self):
        return self.data[0].dword888
    @dword888.setter
    def dword888(self, value):
        self.data[0].dword888 = value
    @property
    def dword88C(self):
        return self.data[0].dword88C
    @dword88C.setter
    def dword88C(self, value):
        self.data[0].dword88C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, SomethingCreature * ptr):
        self.data = ptr
    cdef void _set_ptr(self, SomethingCreature * ptr):
        self.data = ptr
    def set_ptr(self, WrapSomethingCreature v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapCreature:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Creature))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Creature))
    def cast(self, object klass):
        cdef WrapCreature c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapCreature inst = WrapCreature.__new__(WrapCreature)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Creature))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Creature * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Creature))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Creature))
            return
        cdef Creature * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Creature))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Creature))
        self._set_ptr(<Creature*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Creature))
        self._init_ptr(<Creature*>buf)
    @property
    def vtable(self):
        return self.data[0].vtable
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def f4(self):
        if self._f4 is not None:
            return self._f4
        self._f4 = <uint8_t[:4]>(&self.data[0].f4[0])
        return self._f4
    @f4.setter
    def f4(self, value):
        raise NotImplementedError()
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def entity_data(self):
        if self._entity_data is not None:
            return self._entity_data
        self._entity_data = WrapEntityData.__new__(WrapEntityData)
        self._entity_data.holder = self.holder
        self._entity_data._init_ptr(&self.data[0].entity_data)
        return self._entity_data
    @entity_data.setter
    def entity_data(self, value):
        cdef WrapEntityData v = value
        self.data[0].entity_data = v.data[0]
    @property
    def ptr32_1178(self):
        return self.data[0].ptr32_1178
    @ptr32_1178.setter
    def ptr32_1178(self, value):
        self.data[0].ptr32_1178 = value
    @property
    def dword117C(self):
        return self.data[0].dword117C
    @dword117C.setter
    def dword117C(self, value):
        self.data[0].dword117C = value
    @property
    def dword1180(self):
        return self.data[0].dword1180
    @dword1180.setter
    def dword1180(self, value):
        self.data[0].dword1180 = value
    @property
    def dword1184(self):
        return self.data[0].dword1184
    @dword1184.setter
    def dword1184(self, value):
        self.data[0].dword1184 = value
    @property
    def dword1188(self):
        return self.data[0].dword1188
    @dword1188.setter
    def dword1188(self, value):
        self.data[0].dword1188 = value
    @property
    def dword118C(self):
        return self.data[0].dword118C
    @dword118C.setter
    def dword118C(self, value):
        self.data[0].dword118C = value
    @property
    def dword1190(self):
        return self.data[0].dword1190
    @dword1190.setter
    def dword1190(self, value):
        self.data[0].dword1190 = value
    @property
    def float1194(self):
        return self.data[0].float1194
    @float1194.setter
    def float1194(self, value):
        self.data[0].float1194 = value
    @property
    def float1198(self):
        return self.data[0].float1198
    @float1198.setter
    def float1198(self, value):
        self.data[0].float1198 = value
    @property
    def dword119C(self):
        return self.data[0].dword119C
    @dword119C.setter
    def dword119C(self, value):
        self.data[0].dword119C = value
    @property
    def f11A0(self):
        if self._f11A0 is not None:
            return self._f11A0
        self._f11A0 = <uint8_t[:12]>(&self.data[0].f11A0[0])
        return self._f11A0
    @f11A0.setter
    def f11A0(self, value):
        raise NotImplementedError()
    @property
    def mapptr24_11AC(self):
        return self.data[0].mapptr24_11AC
    @mapptr24_11AC.setter
    def mapptr24_11AC(self, value):
        self.data[0].mapptr24_11AC = value
    @property
    def dword11B0(self):
        return self.data[0].dword11B0
    @dword11B0.setter
    def dword11B0(self, value):
        self.data[0].dword11B0 = value
    @property
    def mapptr24_11B4(self):
        return self.data[0].mapptr24_11B4
    @mapptr24_11B4.setter
    def mapptr24_11B4(self, value):
        self.data[0].mapptr24_11B4 = value
    @property
    def dword11B8(self):
        return self.data[0].dword11B8
    @dword11B8.setter
    def dword11B8(self, value):
        self.data[0].dword11B8 = value
    @property
    def f11BC(self):
        if self._f11BC is not None:
            return self._f11BC
        self._f11BC = <uint8_t[:4]>(&self.data[0].f11BC[0])
        return self._f11BC
    @f11BC.setter
    def f11BC(self, value):
        raise NotImplementedError()
    @property
    def dword11C0(self):
        return self.data[0].dword11C0
    @dword11C0.setter
    def dword11C0(self, value):
        self.data[0].dword11C0 = value
    @property
    def dword11C4(self):
        return self.data[0].dword11C4
    @dword11C4.setter
    def dword11C4(self, value):
        self.data[0].dword11C4 = value
    @property
    def dword11C8(self):
        return self.data[0].dword11C8
    @dword11C8.setter
    def dword11C8(self, value):
        self.data[0].dword11C8 = value
    @property
    def dword11CC(self):
        return self.data[0].dword11CC
    @dword11CC.setter
    def dword11CC(self, value):
        self.data[0].dword11CC = value
    @property
    def dword11D0(self):
        return self.data[0].dword11D0
    @dword11D0.setter
    def dword11D0(self, value):
        self.data[0].dword11D0 = value
    @property
    def dword11D4(self):
        return self.data[0].dword11D4
    @dword11D4.setter
    def dword11D4(self, value):
        self.data[0].dword11D4 = value
    @property
    def dword11D8(self):
        return self.data[0].dword11D8
    @dword11D8.setter
    def dword11D8(self, value):
        self.data[0].dword11D8 = value
    @property
    def item_with_extra(self):
        if self._item_with_extra is not None:
            return self._item_with_extra
        self._item_with_extra = WrapItemWithExtra.__new__(WrapItemWithExtra)
        self._item_with_extra.holder = self.holder
        self._item_with_extra._init_ptr(&self.data[0].item_with_extra)
        return self._item_with_extra
    @item_with_extra.setter
    def item_with_extra(self, value):
        cdef WrapItemWithExtra v = value
        self.data[0].item_with_extra = v.data[0]
    @property
    def ptr308_130C(self):
        return self.data[0].ptr308_130C
    @ptr308_130C.setter
    def ptr308_130C(self, value):
        self.data[0].ptr308_130C = value
    @property
    def dword1310(self):
        return self.data[0].dword1310
    @dword1310.setter
    def dword1310(self, value):
        self.data[0].dword1310 = value
    @property
    def dword1314(self):
        return self.data[0].dword1314
    @dword1314.setter
    def dword1314(self, value):
        self.data[0].dword1314 = value
    @property
    def dword1318(self):
        return self.data[0].dword1318
    @dword1318.setter
    def dword1318(self, value):
        self.data[0].dword1318 = value
    @property
    def f131C(self):
        if self._f131C is not None:
            return self._f131C
        self._f131C = <uint8_t[:52]>(&self.data[0].f131C[0])
        return self._f131C
    @f131C.setter
    def f131C(self, value):
        raise NotImplementedError()
    @property
    def dword1350(self):
        return self.data[0].dword1350
    @dword1350.setter
    def dword1350(self, value):
        self.data[0].dword1350 = value
    @property
    def dword1354(self):
        return self.data[0].dword1354
    @dword1354.setter
    def dword1354(self, value):
        self.data[0].dword1354 = value
    @property
    def dword1358(self):
        return self.data[0].dword1358
    @dword1358.setter
    def dword1358(self, value):
        self.data[0].dword1358 = value
    @property
    def dword135C(self):
        return self.data[0].dword135C
    @dword135C.setter
    def dword135C(self, value):
        self.data[0].dword135C = value
    @property
    def dword1360(self):
        return self.data[0].dword1360
    @dword1360.setter
    def dword1360(self, value):
        self.data[0].dword1360 = value
    @property
    def dword1364(self):
        return self.data[0].dword1364
    @dword1364.setter
    def dword1364(self, value):
        self.data[0].dword1364 = value
    @property
    def f1368(self):
        if self._f1368 is not None:
            return self._f1368
        self._f1368 = <uint8_t[:12]>(&self.data[0].f1368[0])
        return self._f1368
    @f1368.setter
    def f1368(self, value):
        raise NotImplementedError()
    @property
    def dword1374(self):
        return self.data[0].dword1374
    @dword1374.setter
    def dword1374(self, value):
        self.data[0].dword1374 = value
    @property
    def dword1378(self):
        return self.data[0].dword1378
    @dword1378.setter
    def dword1378(self, value):
        self.data[0].dword1378 = value
    @property
    def dword137C(self):
        return self.data[0].dword137C
    @dword137C.setter
    def dword137C(self, value):
        self.data[0].dword137C = value
    @property
    def f1380(self):
        if self._f1380 is not None:
            return self._f1380
        self._f1380 = <uint8_t[:24]>(&self.data[0].f1380[0])
        return self._f1380
    @f1380.setter
    def f1380(self, value):
        raise NotImplementedError()
    @property
    def dword1398(self):
        return self.data[0].dword1398
    @dword1398.setter
    def dword1398(self, value):
        self.data[0].dword1398 = value
    @property
    def mapptr24_139C(self):
        return self.data[0].mapptr24_139C
    @mapptr24_139C.setter
    def mapptr24_139C(self, value):
        self.data[0].mapptr24_139C = value
    @property
    def dword13A0(self):
        return self.data[0].dword13A0
    @dword13A0.setter
    def dword13A0(self, value):
        self.data[0].dword13A0 = value
    @property
    def creature_map(self):
        return self.data[0].creature_map
    @creature_map.setter
    def creature_map(self, value):
        self.data[0].creature_map = value
    @property
    def dword13A8(self):
        return self.data[0].dword13A8
    @dword13A8.setter
    def dword13A8(self, value):
        self.data[0].dword13A8 = value
    @property
    def creature_map2(self):
        return self.data[0].creature_map2
    @creature_map2.setter
    def creature_map2(self, value):
        self.data[0].creature_map2 = value
    @property
    def dword13B0(self):
        return self.data[0].dword13B0
    @dword13B0.setter
    def dword13B0(self, value):
        self.data[0].dword13B0 = value
    @property
    def dword13B4(self):
        return self.data[0].dword13B4
    @dword13B4.setter
    def dword13B4(self, value):
        self.data[0].dword13B4 = value
    @property
    def byte13B8(self):
        return self.data[0].byte13B8
    @byte13B8.setter
    def byte13B8(self, value):
        self.data[0].byte13B8 = value
    @property
    def f13B9(self):
        if self._f13B9 is not None:
            return self._f13B9
        self._f13B9 = <uint8_t[:3]>(&self.data[0].f13B9[0])
        return self._f13B9
    @f13B9.setter
    def f13B9(self, value):
        raise NotImplementedError()
    @property
    def dword13BC(self):
        return self.data[0].dword13BC
    @dword13BC.setter
    def dword13BC(self, value):
        self.data[0].dword13BC = value
    @property
    def byte13C0(self):
        return self.data[0].byte13C0
    @byte13C0.setter
    def byte13C0(self, value):
        self.data[0].byte13C0 = value
    @property
    def f13C1(self):
        if self._f13C1 is not None:
            return self._f13C1
        self._f13C1 = <uint8_t[:3]>(&self.data[0].f13C1[0])
        return self._f13C1
    @f13C1.setter
    def f13C1(self, value):
        raise NotImplementedError()
    @property
    def dword13C4(self):
        return self.data[0].dword13C4
    @dword13C4.setter
    def dword13C4(self, value):
        self.data[0].dword13C4 = value
    @property
    def dword13C8(self):
        return self.data[0].dword13C8
    @dword13C8.setter
    def dword13C8(self, value):
        self.data[0].dword13C8 = value
    @property
    def dword13CC(self):
        return self.data[0].dword13CC
    @dword13CC.setter
    def dword13CC(self, value):
        self.data[0].dword13CC = value
    @property
    def dword13D0(self):
        return self.data[0].dword13D0
    @dword13D0.setter
    def dword13D0(self, value):
        self.data[0].dword13D0 = value
    @property
    def dword13D4(self):
        return self.data[0].dword13D4
    @dword13D4.setter
    def dword13D4(self, value):
        self.data[0].dword13D4 = value
    @property
    def dword13D8(self):
        return self.data[0].dword13D8
    @dword13D8.setter
    def dword13D8(self, value):
        self.data[0].dword13D8 = value
    @property
    def dword13DC(self):
        return self.data[0].dword13DC
    @dword13DC.setter
    def dword13DC(self, value):
        self.data[0].dword13DC = value
    @property
    def dword13E0(self):
        return self.data[0].dword13E0
    @dword13E0.setter
    def dword13E0(self, value):
        self.data[0].dword13E0 = value
    @property
    def behaviour(self):
        return self.data[0].behaviour
    @behaviour.setter
    def behaviour(self, value):
        self.data[0].behaviour = value
    @property
    def dword13E8(self):
        return self.data[0].dword13E8
    @dword13E8.setter
    def dword13E8(self, value):
        self.data[0].dword13E8 = value
    @property
    def dword13EC(self):
        return self.data[0].dword13EC
    @dword13EC.setter
    def dword13EC(self, value):
        self.data[0].dword13EC = value
    @property
    def dword13F0(self):
        return self.data[0].dword13F0
    @dword13F0.setter
    def dword13F0(self, value):
        self.data[0].dword13F0 = value
    @property
    def dword13F4(self):
        return self.data[0].dword13F4
    @dword13F4.setter
    def dword13F4(self, value):
        self.data[0].dword13F4 = value
    @property
    def dword13F8(self):
        return self.data[0].dword13F8
    @dword13F8.setter
    def dword13F8(self, value):
        self.data[0].dword13F8 = value
    @property
    def dword13FC(self):
        return self.data[0].dword13FC
    @dword13FC.setter
    def dword13FC(self, value):
        self.data[0].dword13FC = value
    @property
    def dword1400(self):
        return self.data[0].dword1400
    @dword1400.setter
    def dword1400(self, value):
        self.data[0].dword1400 = value
    @property
    def dword1404(self):
        return self.data[0].dword1404
    @dword1404.setter
    def dword1404(self, value):
        self.data[0].dword1404 = value
    @property
    def dword1408(self):
        return self.data[0].dword1408
    @dword1408.setter
    def dword1408(self, value):
        self.data[0].dword1408 = value
    @property
    def mapptr52_140C(self):
        return self.data[0].mapptr52_140C
    @mapptr52_140C.setter
    def mapptr52_140C(self, value):
        self.data[0].mapptr52_140C = value
    @property
    def dword1410(self):
        return self.data[0].dword1410
    @dword1410.setter
    def dword1410(self, value):
        self.data[0].dword1410 = value
    @property
    def mapptr28_1414(self):
        return self.data[0].mapptr28_1414
    @mapptr28_1414.setter
    def mapptr28_1414(self, value):
        self.data[0].mapptr28_1414 = value
    @property
    def dword1418(self):
        return self.data[0].dword1418
    @dword1418.setter
    def dword1418(self, value):
        self.data[0].dword1418 = value
    @property
    def dword141C(self):
        return self.data[0].dword141C
    @dword141C.setter
    def dword141C(self, value):
        self.data[0].dword141C = value
    @property
    def dword1420(self):
        return self.data[0].dword1420
    @dword1420.setter
    def dword1420(self, value):
        self.data[0].dword1420 = value
    @property
    def dword1424(self):
        return self.data[0].dword1424
    @dword1424.setter
    def dword1424(self, value):
        self.data[0].dword1424 = value
    @property
    def f1428(self):
        if self._f1428 is not None:
            return self._f1428
        self._f1428 = <uint8_t[:48]>(&self.data[0].f1428[0])
        return self._f1428
    @f1428.setter
    def f1428(self, value):
        raise NotImplementedError()
    @property
    def dword1458(self):
        return self.data[0].dword1458
    @dword1458.setter
    def dword1458(self, value):
        self.data[0].dword1458 = value
    @property
    def dword145C(self):
        return self.data[0].dword145C
    @dword145C.setter
    def dword145C(self, value):
        self.data[0].dword145C = value
    @property
    def ptr20_1460(self):
        return self.data[0].ptr20_1460
    @ptr20_1460.setter
    def ptr20_1460(self, value):
        self.data[0].ptr20_1460 = value
    @property
    def dword1464(self):
        return self.data[0].dword1464
    @dword1464.setter
    def dword1464(self, value):
        self.data[0].dword1464 = value
    @property
    def mapptr20_1468(self):
        return self.data[0].mapptr20_1468
    @mapptr20_1468.setter
    def mapptr20_1468(self, value):
        self.data[0].mapptr20_1468 = value
    @property
    def dword146C(self):
        return self.data[0].dword146C
    @dword146C.setter
    def dword146C(self, value):
        self.data[0].dword146C = value
    @property
    def ptr20_1470(self):
        return self.data[0].ptr20_1470
    @ptr20_1470.setter
    def ptr20_1470(self, value):
        self.data[0].ptr20_1470 = value
    @property
    def dword1474(self):
        return self.data[0].dword1474
    @dword1474.setter
    def dword1474(self, value):
        self.data[0].dword1474 = value
    @property
    def dword1478(self):
        return self.data[0].dword1478
    @dword1478.setter
    def dword1478(self, value):
        self.data[0].dword1478 = value
    @property
    def dword147C(self):
        return self.data[0].dword147C
    @dword147C.setter
    def dword147C(self, value):
        self.data[0].dword147C = value
    @property
    def dword1480(self):
        return self.data[0].dword1480
    @dword1480.setter
    def dword1480(self, value):
        self.data[0].dword1480 = value
    @property
    def dword1484(self):
        return self.data[0].dword1484
    @dword1484.setter
    def dword1484(self, value):
        self.data[0].dword1484 = value
    @property
    def dword1488(self):
        return self.data[0].dword1488
    @dword1488.setter
    def dword1488(self, value):
        self.data[0].dword1488 = value
    @property
    def dword148C(self):
        return self.data[0].dword148C
    @dword148C.setter
    def dword148C(self, value):
        self.data[0].dword148C = value
    @property
    def dword1490(self):
        return self.data[0].dword1490
    @dword1490.setter
    def dword1490(self, value):
        self.data[0].dword1490 = value
    @property
    def dword1494(self):
        return self.data[0].dword1494
    @dword1494.setter
    def dword1494(self, value):
        self.data[0].dword1494 = value
    @property
    def som_c(self):
        if self._som_c is not None:
            return self._som_c
        self._som_c = WrapSomethingCreature.__new__(WrapSomethingCreature)
        self._som_c.holder = self.holder
        self._som_c._init_ptr(&self.data[0].som_c)
        return self._som_c
    @som_c.setter
    def som_c(self, value):
        cdef WrapSomethingCreature v = value
        self.data[0].som_c = v.data[0]
    @property
    def dword1D28(self):
        return self.data[0].dword1D28
    @dword1D28.setter
    def dword1D28(self, value):
        self.data[0].dword1D28 = value
    @property
    def float1D2C(self):
        return self.data[0].float1D2C
    @float1D2C.setter
    def float1D2C(self, value):
        self.data[0].float1D2C = value
    @property
    def f1D30(self):
        if self._f1D30 is not None:
            return self._f1D30
        self._f1D30 = <uint8_t[:8]>(&self.data[0].f1D30[0])
        return self._f1D30
    @f1D30.setter
    def f1D30(self, value):
        raise NotImplementedError()
    @property
    def byte1D38(self):
        return self.data[0].byte1D38
    @byte1D38.setter
    def byte1D38(self, value):
        self.data[0].byte1D38 = value
    @property
    def f1D39(self):
        if self._f1D39 is not None:
            return self._f1D39
        self._f1D39 = <uint8_t[:3]>(&self.data[0].f1D39[0])
        return self._f1D39
    @f1D39.setter
    def f1D39(self, value):
        raise NotImplementedError()
    @property
    def dword1D3C(self):
        return self.data[0].dword1D3C
    @dword1D3C.setter
    def dword1D3C(self, value):
        self.data[0].dword1D3C = value
    @property
    def dword1D40(self):
        return self.data[0].dword1D40
    @dword1D40.setter
    def dword1D40(self, value):
        self.data[0].dword1D40 = value
    @property
    def dword1D44(self):
        return self.data[0].dword1D44
    @dword1D44.setter
    def dword1D44(self, value):
        self.data[0].dword1D44 = value
    @property
    def word1D48(self):
        return self.data[0].word1D48
    @word1D48.setter
    def word1D48(self, value):
        self.data[0].word1D48 = value
    @property
    def f1D4A(self):
        if self._f1D4A is not None:
            return self._f1D4A
        self._f1D4A = <uint8_t[:2]>(&self.data[0].f1D4A[0])
        return self._f1D4A
    @f1D4A.setter
    def f1D4A(self, value):
        raise NotImplementedError()
    @property
    def dword1D4C(self):
        return self.data[0].dword1D4C
    @dword1D4C.setter
    def dword1D4C(self, value):
        self.data[0].dword1D4C = value
    @property
    def dword1D50(self):
        return self.data[0].dword1D50
    @dword1D50.setter
    def dword1D50(self, value):
        self.data[0].dword1D50 = value
    @property
    def word1D54(self):
        return self.data[0].word1D54
    @word1D54.setter
    def word1D54(self, value):
        self.data[0].word1D54 = value
    @property
    def byte1D56(self):
        return self.data[0].byte1D56
    @byte1D56.setter
    def byte1D56(self, value):
        self.data[0].byte1D56 = value
    @property
    def f1D57(self):
        if self._f1D57 is not None:
            return self._f1D57
        self._f1D57 = <uint8_t[:1]>(&self.data[0].f1D57[0])
        return self._f1D57
    @f1D57.setter
    def f1D57(self, value):
        raise NotImplementedError()
    @property
    def word1D58(self):
        return self.data[0].word1D58
    @word1D58.setter
    def word1D58(self, value):
        self.data[0].word1D58 = value
    @property
    def f1D5A(self):
        if self._f1D5A is not None:
            return self._f1D5A
        self._f1D5A = <uint8_t[:2]>(&self.data[0].f1D5A[0])
        return self._f1D5A
    @f1D5A.setter
    def f1D5A(self, value):
        raise NotImplementedError()
    @property
    def char1D5C(self):
        if self._char1D5C is not None:
            return self._char1D5C
        self._char1D5C = <int8_t[:256]>(&self.data[0].char1D5C[0])
        return self._char1D5C
    @char1D5C.setter
    def char1D5C(self, value):
        raise NotImplementedError()
    @property
    def dword1E5C(self):
        return self.data[0].dword1E5C
    @dword1E5C.setter
    def dword1E5C(self, value):
        self.data[0].dword1E5C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Creature * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Creature * ptr):
        self.data = ptr
        if self._f4 is not None:
            self._f4.data = <char*>(&self.data[0].f4[0])
        if self._entity_data is not None:
            self._entity_data.holder = self.holder
            self._entity_data._set_ptr(&self.data[0].entity_data)
        if self._f11A0 is not None:
            self._f11A0.data = <char*>(&self.data[0].f11A0[0])
        if self._f11BC is not None:
            self._f11BC.data = <char*>(&self.data[0].f11BC[0])
        if self._item_with_extra is not None:
            self._item_with_extra.holder = self.holder
            self._item_with_extra._set_ptr(&self.data[0].item_with_extra)
        if self._f131C is not None:
            self._f131C.data = <char*>(&self.data[0].f131C[0])
        if self._f1368 is not None:
            self._f1368.data = <char*>(&self.data[0].f1368[0])
        if self._f1380 is not None:
            self._f1380.data = <char*>(&self.data[0].f1380[0])
        if self._f13B9 is not None:
            self._f13B9.data = <char*>(&self.data[0].f13B9[0])
        if self._f13C1 is not None:
            self._f13C1.data = <char*>(&self.data[0].f13C1[0])
        if self._f1428 is not None:
            self._f1428.data = <char*>(&self.data[0].f1428[0])
        if self._som_c is not None:
            self._som_c.holder = self.holder
            self._som_c._set_ptr(&self.data[0].som_c)
        if self._f1D30 is not None:
            self._f1D30.data = <char*>(&self.data[0].f1D30[0])
        if self._f1D39 is not None:
            self._f1D39.data = <char*>(&self.data[0].f1D39[0])
        if self._f1D4A is not None:
            self._f1D4A.data = <char*>(&self.data[0].f1D4A[0])
        if self._f1D57 is not None:
            self._f1D57.data = <char*>(&self.data[0].f1D57[0])
        if self._f1D5A is not None:
            self._f1D5A.data = <char*>(&self.data[0].f1D5A[0])
        if self._char1D5C is not None:
            self._char1D5C.data = <char*>(&self.data[0].char1D5C[0])
    def set_ptr(self, WrapCreature v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapHitPacket:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(HitPacket))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(HitPacket))
    def cast(self, object klass):
        cdef WrapHitPacket c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapHitPacket inst = WrapHitPacket.__new__(WrapHitPacket)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(HitPacket))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef HitPacket * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(HitPacket))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(HitPacket))
            return
        cdef HitPacket * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(HitPacket))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(HitPacket))
        self._set_ptr(<HitPacket*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(HitPacket))
        self._init_ptr(<HitPacket*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def target_id(self):
        return self.data[0].target_id
    @target_id.setter
    def target_id(self, value):
        self.data[0].target_id = value
    @property
    def damage(self):
        return self.data[0].damage
    @damage.setter
    def damage(self, value):
        self.data[0].damage = value
    @property
    def critical(self):
        return self.data[0].critical
    @critical.setter
    def critical(self, value):
        self.data[0].critical = value
    @property
    def stun_duration(self):
        return self.data[0].stun_duration
    @stun_duration.setter
    def stun_duration(self, value):
        self.data[0].stun_duration = value
    @property
    def something8(self):
        return self.data[0].something8
    @something8.setter
    def something8(self, value):
        self.data[0].something8 = value
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def hit_dir(self):
        if self._hit_dir is not None:
            return self._hit_dir
        Py_INCREF(dtype_float32)
        cdef float * hit_dirptr = &self.data[0].hit_dir[0]
        self._hit_dir = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>hit_dirptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._hit_dir, self.holder)
        return self._hit_dir
    @hit_dir.setter
    def hit_dir(self, value):
        cdef float[3] arr = value
        self.data[0].hit_dir = arr
    @property
    def skill_hit(self):
        return self.data[0].skill_hit
    @skill_hit.setter
    def skill_hit(self, value):
        self.data[0].skill_hit = value
    @property
    def hit_type(self):
        return self.data[0].hit_type
    @hit_type.setter
    def hit_type(self, value):
        self.data[0].hit_type = value
    @property
    def show_light(self):
        return self.data[0].show_light
    @show_light.setter
    def show_light(self, value):
        self.data[0].show_light = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, HitPacket * ptr):
        self.data = ptr
    cdef void _set_ptr(self, HitPacket * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._hit_dir is not None:
            set_array_base(self._hit_dir, self.holder)
            self._hit_dir.data = <char*>&self.data[0].hit_dir
    def set_ptr(self, WrapHitPacket v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapParticleData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ParticleData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ParticleData))
    def cast(self, object klass):
        cdef WrapParticleData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapParticleData inst = WrapParticleData.__new__(WrapParticleData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ParticleData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ParticleData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ParticleData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ParticleData))
            return
        cdef ParticleData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ParticleData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ParticleData))
        self._set_ptr(<ParticleData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ParticleData))
        self._init_ptr(<ParticleData*>buf)
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def accel(self):
        if self._accel is not None:
            return self._accel
        Py_INCREF(dtype_float32)
        cdef float * accelptr = &self.data[0].accel[0]
        self._accel = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>accelptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._accel, self.holder)
        return self._accel
    @accel.setter
    def accel(self, value):
        cdef float[3] arr = value
        self.data[0].accel = arr
    @property
    def color(self):
        if self._color is not None:
            return self._color
        self._color = <float[:4]>(&self.data[0].color[0])
        return self._color
    @color.setter
    def color(self, value):
        raise NotImplementedError()
    @property
    def scale(self):
        return self.data[0].scale
    @scale.setter
    def scale(self, value):
        self.data[0].scale = value
    @property
    def count(self):
        return self.data[0].count
    @count.setter
    def count(self, value):
        self.data[0].count = value
    @property
    def particle_type(self):
        return self.data[0].particle_type
    @particle_type.setter
    def particle_type(self, value):
        self.data[0].particle_type = value
    @property
    def spreading(self):
        return self.data[0].spreading
    @spreading.setter
    def spreading(self, value):
        self.data[0].spreading = value
    @property
    def something18(self):
        return self.data[0].something18
    @something18.setter
    def something18(self, value):
        self.data[0].something18 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ParticleData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ParticleData * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._accel is not None:
            set_array_base(self._accel, self.holder)
            self._accel.data = <char*>&self.data[0].accel
        if self._color is not None:
            self._color.data = <char*>(&self.data[0].color[0])
    def set_ptr(self, WrapParticleData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapSoundAction:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(SoundAction))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(SoundAction))
    def cast(self, object klass):
        cdef WrapSoundAction c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapSoundAction inst = WrapSoundAction.__new__(WrapSoundAction)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(SoundAction))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef SoundAction * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(SoundAction))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(SoundAction))
            return
        cdef SoundAction * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(SoundAction))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SoundAction))
        self._set_ptr(<SoundAction*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SoundAction))
        self._init_ptr(<SoundAction*>buf)
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_float32)
        cdef float * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef float[3] arr = value
        self.data[0].pos = arr
    @property
    def sound_index(self):
        return self.data[0].sound_index
    @sound_index.setter
    def sound_index(self, value):
        self.data[0].sound_index = value
    @property
    def pitch(self):
        return self.data[0].pitch
    @pitch.setter
    def pitch(self, value):
        self.data[0].pitch = value
    @property
    def volume(self):
        return self.data[0].volume
    @volume.setter
    def volume(self, value):
        self.data[0].volume = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, SoundAction * ptr):
        self.data = ptr
    cdef void _set_ptr(self, SoundAction * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
    def set_ptr(self, WrapSoundAction v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapBlockAction:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(BlockAction))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(BlockAction))
    def cast(self, object klass):
        cdef WrapBlockAction c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapBlockAction inst = WrapBlockAction.__new__(WrapBlockAction)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(BlockAction))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef BlockAction * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(BlockAction))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(BlockAction))
            return
        cdef BlockAction * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(BlockAction))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(BlockAction))
        self._set_ptr(<BlockAction*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(BlockAction))
        self._init_ptr(<BlockAction*>buf)
    @property
    def block_pos(self):
        if self._block_pos is not None:
            return self._block_pos
        Py_INCREF(dtype_int32)
        cdef int32_t * block_posptr = &self.data[0].block_pos[0]
        self._block_pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int32, 1, &vec3_dim, NULL, <void*>block_posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._block_pos, self.holder)
        return self._block_pos
    @block_pos.setter
    def block_pos(self, value):
        cdef int32_t[3] arr = value
        self.data[0].block_pos = arr
    @property
    def color_red(self):
        return self.data[0].color_red
    @color_red.setter
    def color_red(self, value):
        self.data[0].color_red = value
    @property
    def color_green(self):
        return self.data[0].color_green
    @color_green.setter
    def color_green(self, value):
        self.data[0].color_green = value
    @property
    def color_blue(self):
        return self.data[0].color_blue
    @color_blue.setter
    def color_blue(self, value):
        self.data[0].color_blue = value
    @property
    def block_type(self):
        return self.data[0].block_type
    @block_type.setter
    def block_type(self, value):
        self.data[0].block_type = value
    @property
    def something8(self):
        return self.data[0].something8
    @something8.setter
    def something8(self, value):
        self.data[0].something8 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, BlockAction * ptr):
        self.data = ptr
    cdef void _set_ptr(self, BlockAction * ptr):
        self.data = ptr
        if self._block_pos is not None:
            set_array_base(self._block_pos, self.holder)
            self._block_pos.data = <char*>&self.data[0].block_pos
    def set_ptr(self, WrapBlockAction v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapShootPacket:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ShootPacket))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ShootPacket))
    def cast(self, object klass):
        cdef WrapShootPacket c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapShootPacket inst = WrapShootPacket.__new__(WrapShootPacket)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ShootPacket))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ShootPacket * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ShootPacket))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ShootPacket))
            return
        cdef ShootPacket * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ShootPacket))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ShootPacket))
        self._set_ptr(<ShootPacket*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ShootPacket))
        self._init_ptr(<ShootPacket*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def chunk_x(self):
        return self.data[0].chunk_x
    @chunk_x.setter
    def chunk_x(self, value):
        self.data[0].chunk_x = value
    @property
    def chunk_y(self):
        return self.data[0].chunk_y
    @chunk_y.setter
    def chunk_y(self, value):
        self.data[0].chunk_y = value
    @property
    def something5(self):
        return self.data[0].something5
    @something5.setter
    def something5(self, value):
        self.data[0].something5 = value
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def something13(self):
        return self.data[0].something13
    @something13.setter
    def something13(self, value):
        self.data[0].something13 = value
    @property
    def something14(self):
        return self.data[0].something14
    @something14.setter
    def something14(self, value):
        self.data[0].something14 = value
    @property
    def something15(self):
        return self.data[0].something15
    @something15.setter
    def something15(self, value):
        self.data[0].something15 = value
    @property
    def velocity(self):
        if self._velocity is not None:
            return self._velocity
        Py_INCREF(dtype_float32)
        cdef float * velocityptr = &self.data[0].velocity[0]
        self._velocity = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>velocityptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._velocity, self.holder)
        return self._velocity
    @velocity.setter
    def velocity(self, value):
        cdef float[3] arr = value
        self.data[0].velocity = arr
    @property
    def legacy_damage(self):
        return self.data[0].legacy_damage
    @legacy_damage.setter
    def legacy_damage(self, value):
        self.data[0].legacy_damage = value
    @property
    def something20(self):
        return self.data[0].something20
    @something20.setter
    def something20(self, value):
        self.data[0].something20 = value
    @property
    def scale(self):
        return self.data[0].scale
    @scale.setter
    def scale(self, value):
        self.data[0].scale = value
    @property
    def mana(self):
        return self.data[0].mana
    @mana.setter
    def mana(self, value):
        self.data[0].mana = value
    @property
    def particles(self):
        return self.data[0].particles
    @particles.setter
    def particles(self, value):
        self.data[0].particles = value
    @property
    def skill(self):
        return self.data[0].skill
    @skill.setter
    def skill(self, value):
        self.data[0].skill = value
    @property
    def projectile(self):
        return self.data[0].projectile
    @projectile.setter
    def projectile(self, value):
        self.data[0].projectile = value
    @property
    def something26(self):
        return self.data[0].something26
    @something26.setter
    def something26(self, value):
        self.data[0].something26 = value
    @property
    def something27(self):
        return self.data[0].something27
    @something27.setter
    def something27(self, value):
        self.data[0].something27 = value
    @property
    def something28(self):
        return self.data[0].something28
    @something28.setter
    def something28(self, value):
        self.data[0].something28 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ShootPacket * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ShootPacket * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._velocity is not None:
            set_array_base(self._velocity, self.holder)
            self._velocity.data = <char*>&self.data[0].velocity
    def set_ptr(self, WrapShootPacket v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapPickupAction:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(PickupAction))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(PickupAction))
    def cast(self, object klass):
        cdef WrapPickupAction c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapPickupAction inst = WrapPickupAction.__new__(WrapPickupAction)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(PickupAction))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef PickupAction * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(PickupAction))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(PickupAction))
            return
        cdef PickupAction * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(PickupAction))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PickupAction))
        self._set_ptr(<PickupAction*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PickupAction))
        self._init_ptr(<PickupAction*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def item_data(self):
        if self._item_data is not None:
            return self._item_data
        self._item_data = WrapItemData.__new__(WrapItemData)
        self._item_data.holder = self.holder
        self._item_data._init_ptr(&self.data[0].item_data)
        return self._item_data
    @item_data.setter
    def item_data(self, value):
        cdef WrapItemData v = value
        self.data[0].item_data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, PickupAction * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PickupAction * ptr):
        self.data = ptr
        if self._item_data is not None:
            self._item_data.holder = self.holder
            self._item_data._set_ptr(&self.data[0].item_data)
    def set_ptr(self, WrapPickupAction v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapKillAction:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(KillAction))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(KillAction))
    def cast(self, object klass):
        cdef WrapKillAction c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapKillAction inst = WrapKillAction.__new__(WrapKillAction)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(KillAction))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef KillAction * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(KillAction))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(KillAction))
            return
        cdef KillAction * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(KillAction))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(KillAction))
        self._set_ptr(<KillAction*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(KillAction))
        self._init_ptr(<KillAction*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def target_id(self):
        return self.data[0].target_id
    @target_id.setter
    def target_id(self, value):
        self.data[0].target_id = value
    @property
    def xp_gained(self):
        return self.data[0].xp_gained
    @xp_gained.setter
    def xp_gained(self, value):
        self.data[0].xp_gained = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, KillAction * ptr):
        self.data = ptr
    cdef void _set_ptr(self, KillAction * ptr):
        self.data = ptr
    def set_ptr(self, WrapKillAction v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapDamageAction:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(DamageAction))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(DamageAction))
    def cast(self, object klass):
        cdef WrapDamageAction c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapDamageAction inst = WrapDamageAction.__new__(WrapDamageAction)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(DamageAction))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef DamageAction * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(DamageAction))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(DamageAction))
            return
        cdef DamageAction * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(DamageAction))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(DamageAction))
        self._set_ptr(<DamageAction*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(DamageAction))
        self._init_ptr(<DamageAction*>buf)
    @property
    def target_id(self):
        return self.data[0].target_id
    @target_id.setter
    def target_id(self, value):
        self.data[0].target_id = value
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def damage(self):
        return self.data[0].damage
    @damage.setter
    def damage(self, value):
        self.data[0].damage = value
    @property
    def skip(self):
        if self._skip is not None:
            return self._skip
        self._skip = <int8_t[:4]>(&self.data[0].skip[0])
        return self._skip
    @skip.setter
    def skip(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, DamageAction * ptr):
        self.data = ptr
    cdef void _set_ptr(self, DamageAction * ptr):
        self.data = ptr
        if self._skip is not None:
            self._skip.data = <char*>(&self.data[0].skip[0])
    def set_ptr(self, WrapDamageAction v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapPassivePacket:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(PassivePacket))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(PassivePacket))
    def cast(self, object klass):
        cdef WrapPassivePacket c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapPassivePacket inst = WrapPassivePacket.__new__(WrapPassivePacket)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(PassivePacket))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef PassivePacket * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(PassivePacket))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(PassivePacket))
            return
        cdef PassivePacket * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(PassivePacket))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PassivePacket))
        self._set_ptr(<PassivePacket*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PassivePacket))
        self._init_ptr(<PassivePacket*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def target_id(self):
        return self.data[0].target_id
    @target_id.setter
    def target_id(self, value):
        self.data[0].target_id = value
    @property
    def passive_type(self):
        return self.data[0].passive_type
    @passive_type.setter
    def passive_type(self, value):
        self.data[0].passive_type = value
    @property
    def modifier(self):
        return self.data[0].modifier
    @modifier.setter
    def modifier(self, value):
        self.data[0].modifier = value
    @property
    def duration(self):
        return self.data[0].duration
    @duration.setter
    def duration(self, value):
        self.data[0].duration = value
    @property
    def target_id2(self):
        return self.data[0].target_id2
    @target_id2.setter
    def target_id2(self, value):
        self.data[0].target_id2 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, PassivePacket * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PassivePacket * ptr):
        self.data = ptr
    def set_ptr(self, WrapPassivePacket v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapMissionInfo:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(MissionInfo))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(MissionInfo))
    def cast(self, object klass):
        cdef WrapMissionInfo c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapMissionInfo inst = WrapMissionInfo.__new__(WrapMissionInfo)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(MissionInfo))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef MissionInfo * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(MissionInfo))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(MissionInfo))
            return
        cdef MissionInfo * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(MissionInfo))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionInfo))
        self._set_ptr(<MissionInfo*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionInfo))
        self._init_ptr(<MissionInfo*>buf)
    @property
    def something3(self):
        return self.data[0].something3
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def mission_id(self):
        return self.data[0].mission_id
    @mission_id.setter
    def mission_id(self, value):
        self.data[0].mission_id = value
    @property
    def mission_desc_id(self):
        return self.data[0].mission_desc_id
    @mission_desc_id.setter
    def mission_desc_id(self, value):
        self.data[0].mission_desc_id = value
    @property
    def monster_race_id(self):
        return self.data[0].monster_race_id
    @monster_race_id.setter
    def monster_race_id(self, value):
        self.data[0].monster_race_id = value
    @property
    def monster_level(self):
        return self.data[0].monster_level
    @monster_level.setter
    def monster_level(self, value):
        self.data[0].monster_level = value
    @property
    def something8(self):
        return self.data[0].something8
    @something8.setter
    def something8(self, value):
        self.data[0].something8 = value
    @property
    def state(self):
        return self.data[0].state
    @state.setter
    def state(self, value):
        self.data[0].state = value
    @property
    def progress_bar_current(self):
        return self.data[0].progress_bar_current
    @progress_bar_current.setter
    def progress_bar_current(self, value):
        self.data[0].progress_bar_current = value
    @property
    def progress_bar_max(self):
        return self.data[0].progress_bar_max
    @progress_bar_max.setter
    def progress_bar_max(self, value):
        self.data[0].progress_bar_max = value
    @property
    def chunk_x(self):
        return self.data[0].chunk_x
    @chunk_x.setter
    def chunk_x(self, value):
        self.data[0].chunk_x = value
    @property
    def chunk_y(self):
        return self.data[0].chunk_y
    @chunk_y.setter
    def chunk_y(self, value):
        self.data[0].chunk_y = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, MissionInfo * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionInfo * ptr):
        self.data = ptr
    def set_ptr(self, WrapMissionInfo v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapMissionPacket:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(MissionPacket))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(MissionPacket))
    def cast(self, object klass):
        cdef WrapMissionPacket c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapMissionPacket inst = WrapMissionPacket.__new__(WrapMissionPacket)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(MissionPacket))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef MissionPacket * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(MissionPacket))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(MissionPacket))
            return
        cdef MissionPacket * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(MissionPacket))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionPacket))
        self._set_ptr(<MissionPacket*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionPacket))
        self._init_ptr(<MissionPacket*>buf)
    @property
    def x(self):
        return self.data[0].x
    @x.setter
    def x(self, value):
        self.data[0].x = value
    @property
    def y(self):
        return self.data[0].y
    @y.setter
    def y(self, value):
        self.data[0].y = value
    @property
    def something1(self):
        return self.data[0].something1
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def something2(self):
        return self.data[0].something2
    @something2.setter
    def something2(self, value):
        self.data[0].something2 = value
    @property
    def info(self):
        if self._info is not None:
            return self._info
        self._info = WrapMissionInfo.__new__(WrapMissionInfo)
        self._info.holder = self.holder
        self._info._init_ptr(&self.data[0].info)
        return self._info
    @info.setter
    def info(self, value):
        cdef WrapMissionInfo v = value
        self.data[0].info = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, MissionPacket * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionPacket * ptr):
        self.data = ptr
        if self._info is not None:
            self._info.holder = self.holder
            self._info._set_ptr(&self.data[0].info)
    def set_ptr(self, WrapMissionPacket v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapMissionData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(MissionData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(MissionData))
    def cast(self, object klass):
        cdef WrapMissionData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapMissionData inst = WrapMissionData.__new__(WrapMissionData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(MissionData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef MissionData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(MissionData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(MissionData))
            return
        cdef MissionData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(MissionData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionData))
        self._set_ptr(<MissionData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionData))
        self._init_ptr(<MissionData*>buf)
    @property
    def origin_x(self):
        return self.data[0].origin_x
    @origin_x.setter
    def origin_x(self, value):
        self.data[0].origin_x = value
    @property
    def origin_y(self):
        return self.data[0].origin_y
    @origin_y.setter
    def origin_y(self, value):
        self.data[0].origin_y = value
    @property
    def size(self):
        return self.data[0].size
    @size.setter
    def size(self, value):
        self.data[0].size = value
    @property
    def unk_float(self):
        return self.data[0].unk_float
    @unk_float.setter
    def unk_float(self, value):
        self.data[0].unk_float = value
    @property
    def place_category_id(self):
        return self.data[0].place_category_id
    @place_category_id.setter
    def place_category_id(self, value):
        self.data[0].place_category_id = value
    @property
    def place_item_id(self):
        return self.data[0].place_item_id
    @place_item_id.setter
    def place_item_id(self, value):
        self.data[0].place_item_id = value
    @property
    def namegen_id(self):
        return self.data[0].namegen_id
    @namegen_id.setter
    def namegen_id(self, value):
        self.data[0].namegen_id = value
    @property
    def area_level(self):
        return self.data[0].area_level
    @area_level.setter
    def area_level(self, value):
        self.data[0].area_level = value
    @property
    def dword28(self):
        return self.data[0].dword28
    @dword28.setter
    def dword28(self, value):
        self.data[0].dword28 = value
    @property
    def info(self):
        if self._info is not None:
            return self._info
        self._info = WrapMissionInfo.__new__(WrapMissionInfo)
        self._info.holder = self.holder
        self._info._init_ptr(&self.data[0].info)
        return self._info
    @info.setter
    def info(self, value):
        cdef WrapMissionInfo v = value
        self.data[0].info = v.data[0]
    @property
    def dword54(self):
        return self.data[0].dword54
    @dword54.setter
    def dword54(self, value):
        self.data[0].dword54 = value
    @property
    def dword58(self):
        return self.data[0].dword58
    @dword58.setter
    def dword58(self, value):
        self.data[0].dword58 = value
    @property
    def byte5C(self):
        return self.data[0].byte5C
    @byte5C.setter
    def byte5C(self, value):
        self.data[0].byte5C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, MissionData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionData * ptr):
        self.data = ptr
        if self._info is not None:
            self._info.holder = self.holder
            self._info._set_ptr(&self.data[0].info)
    def set_ptr(self, WrapMissionData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapRegionSomething:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(RegionSomething))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(RegionSomething))
    def cast(self, object klass):
        cdef WrapRegionSomething c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapRegionSomething inst = WrapRegionSomething.__new__(WrapRegionSomething)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(RegionSomething))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef RegionSomething * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(RegionSomething))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(RegionSomething))
            return
        cdef RegionSomething * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(RegionSomething))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(RegionSomething))
        self._set_ptr(<RegionSomething*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(RegionSomething))
        self._init_ptr(<RegionSomething*>buf)
    @property
    def field_0(self):
        return self.data[0].field_0
    @field_0.setter
    def field_0(self, value):
        self.data[0].field_0 = value
    @property
    def field_4(self):
        return self.data[0].field_4
    @field_4.setter
    def field_4(self, value):
        self.data[0].field_4 = value
    @property
    def field_8(self):
        return self.data[0].field_8
    @field_8.setter
    def field_8(self, value):
        self.data[0].field_8 = value
    @property
    def field_C(self):
        return self.data[0].field_C
    @field_C.setter
    def field_C(self, value):
        self.data[0].field_C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, RegionSomething * ptr):
        self.data = ptr
    cdef void _set_ptr(self, RegionSomething * ptr):
        self.data = ptr
    def set_ptr(self, WrapRegionSomething v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapRegionSeed:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(RegionSeed))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(RegionSeed))
    def cast(self, object klass):
        cdef WrapRegionSeed c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapRegionSeed inst = WrapRegionSeed.__new__(WrapRegionSeed)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(RegionSeed))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef RegionSeed * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(RegionSeed))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(RegionSeed))
            return
        cdef RegionSeed * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(RegionSeed))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(RegionSeed))
        self._set_ptr(<RegionSeed*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(RegionSeed))
        self._init_ptr(<RegionSeed*>buf)
    @property
    def dword0(self):
        return self.data[0].dword0
    @dword0.setter
    def dword0(self, value):
        self.data[0].dword0 = value
    @property
    def dword4(self):
        return self.data[0].dword4
    @dword4.setter
    def dword4(self, value):
        self.data[0].dword4 = value
    @property
    def byte8(self):
        return self.data[0].byte8
    @byte8.setter
    def byte8(self, value):
        self.data[0].byte8 = value
    @property
    def floatC(self):
        return self.data[0].floatC
    @floatC.setter
    def floatC(self, value):
        self.data[0].floatC = value
    @property
    def float10(self):
        return self.data[0].float10
    @float10.setter
    def float10(self, value):
        self.data[0].float10 = value
    @property
    def dword14(self):
        return self.data[0].dword14
    @dword14.setter
    def dword14(self, value):
        self.data[0].dword14 = value
    @property
    def dword18(self):
        return self.data[0].dword18
    @dword18.setter
    def dword18(self, value):
        self.data[0].dword18 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, RegionSeed * ptr):
        self.data = ptr
    cdef void _set_ptr(self, RegionSeed * ptr):
        self.data = ptr
    def set_ptr(self, WrapRegionSeed v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapRegion:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Region))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Region))
    def cast(self, object klass):
        cdef WrapRegion c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapRegion inst = WrapRegion.__new__(WrapRegion)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Region))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Region * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Region))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Region))
            return
        cdef Region * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Region))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Region))
        self._set_ptr(<Region*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Region))
        self._init_ptr(<Region*>buf)
    @property
    def vtable(self):
        return self.data[0].vtable
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def set_to_one1(self):
        return self.data[0].set_to_one1
    @set_to_one1.setter
    def set_to_one1(self, value):
        self.data[0].set_to_one1 = value
    @property
    def set_to_one2(self):
        return self.data[0].set_to_one2
    @set_to_one2.setter
    def set_to_one2(self, value):
        self.data[0].set_to_one2 = value
    @property
    def dword10(self):
        return self.data[0].dword10
    @dword10.setter
    def dword10(self, value):
        self.data[0].dword10 = value
    @property
    def dword14(self):
        return self.data[0].dword14
    @dword14.setter
    def dword14(self, value):
        self.data[0].dword14 = value
    @property
    def regsomething(self):
        if self._regsomething is not None:
            return self._regsomething
        self._regsomething = WrapArray5.__new__(WrapArray5)
        self._regsomething.holder = self.holder
        self._regsomething._init_ptr(&self.data[0].regsomething[0])
        return self._regsomething
    @regsomething.setter
    def regsomething(self, value):
        raise NotImplementedError()
    @property
    def zones(self):
        if self._zones is not None:
            return self._zones
        self._zones = WrapArray6.__new__(WrapArray6)
        self._zones.holder = self.holder
        self._zones._init_ptr(&self.data[0].zones[0])
        return self._zones
    @zones.setter
    def zones(self, value):
        raise NotImplementedError()
    @property
    def missions(self):
        if self._missions is not None:
            return self._missions
        self._missions = WrapArray7.__new__(WrapArray7)
        self._missions.holder = self.holder
        self._missions._init_ptr(&self.data[0].missions[0])
        return self._missions
    @missions.setter
    def missions(self, value):
        raise NotImplementedError()
    @property
    def byte15A18(self):
        return self.data[0].byte15A18
    @byte15A18.setter
    def byte15A18(self, value):
        self.data[0].byte15A18 = value
    @property
    def dword15A1C(self):
        return self.data[0].dword15A1C
    @dword15A1C.setter
    def dword15A1C(self, value):
        self.data[0].dword15A1C = value
    @property
    def dword15A20(self):
        return self.data[0].dword15A20
    @dword15A20.setter
    def dword15A20(self, value):
        self.data[0].dword15A20 = value
    @property
    def dword15A24(self):
        return self.data[0].dword15A24
    @dword15A24.setter
    def dword15A24(self, value):
        self.data[0].dword15A24 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Region * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Region * ptr):
        self.data = ptr
        if self._regsomething is not None:
            self._regsomething.holder = self.holder
            self._regsomething._set_ptr(&self.data[0].regsomething[0])
        if self._zones is not None:
            self._zones.holder = self.holder
            self._zones._set_ptr(&self.data[0].zones[0])
        if self._missions is not None:
            self._missions.holder = self.holder
            self._missions._set_ptr(&self.data[0].missions[0])
    def set_ptr(self, WrapRegion v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapAirshipData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(AirshipData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(AirshipData))
    def cast(self, object klass):
        cdef WrapAirshipData c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapAirshipData inst = WrapAirshipData.__new__(WrapAirshipData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(AirshipData))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef AirshipData * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(AirshipData))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(AirshipData))
            return
        cdef AirshipData * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(AirshipData))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(AirshipData))
        self._set_ptr(<AirshipData*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(AirshipData))
        self._init_ptr(<AirshipData*>buf)
    @property
    def entity_id(self):
        return self.data[0].entity_id
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def something1(self):
        return self.data[0].something1
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def something2(self):
        return self.data[0].something2
    @something2.setter
    def something2(self, value):
        self.data[0].something2 = value
    @property
    def pos(self):
        if self._pos is not None:
            return self._pos
        Py_INCREF(dtype_int64)
        cdef int64_t * posptr = &self.data[0].pos[0]
        self._pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._pos, self.holder)
        return self._pos
    @pos.setter
    def pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].pos = arr
    @property
    def velocity(self):
        if self._velocity is not None:
            return self._velocity
        Py_INCREF(dtype_float32)
        cdef float * velocityptr = &self.data[0].velocity[0]
        self._velocity = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>velocityptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._velocity, self.holder)
        return self._velocity
    @velocity.setter
    def velocity(self, value):
        cdef float[3] arr = value
        self.data[0].velocity = arr
    @property
    def rotation(self):
        if self._rotation is not None:
            return self._rotation
        Py_INCREF(dtype_float32)
        cdef float * rotationptr = &self.data[0].rotation[0]
        self._rotation = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_float32, 1, &vec3_dim, NULL, <void*>rotationptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._rotation, self.holder)
        return self._rotation
    @rotation.setter
    def rotation(self, value):
        cdef float[3] arr = value
        self.data[0].rotation = arr
    @property
    def start_pos(self):
        if self._start_pos is not None:
            return self._start_pos
        Py_INCREF(dtype_int64)
        cdef int64_t * start_posptr = &self.data[0].start_pos[0]
        self._start_pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>start_posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._start_pos, self.holder)
        return self._start_pos
    @start_pos.setter
    def start_pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].start_pos = arr
    @property
    def path_rotation(self):
        return self.data[0].path_rotation
    @path_rotation.setter
    def path_rotation(self, value):
        self.data[0].path_rotation = value
    @property
    def something3(self):
        return self.data[0].something3
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def dest_pos(self):
        if self._dest_pos is not None:
            return self._dest_pos
        Py_INCREF(dtype_int64)
        cdef int64_t * dest_posptr = &self.data[0].dest_pos[0]
        self._dest_pos = PyArray_NewFromDescr(<PyTypeObject *>Vector3, dtype_int64, 1, &vec3_dim, NULL, <void*>dest_posptr, np.NPY_DEFAULT, <object>NULL);
        set_array_base(self._dest_pos, self.holder)
        return self._dest_pos
    @dest_pos.setter
    def dest_pos(self, value):
        cdef int64_t[3] arr = value
        self.data[0].dest_pos = arr
    @property
    def stage(self):
        return self.data[0].stage
    @stage.setter
    def stage(self, value):
        self.data[0].stage = value
    @property
    def something4(self):
        return self.data[0].something4
    @something4.setter
    def something4(self, value):
        self.data[0].something4 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, AirshipData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, AirshipData * ptr):
        self.data = ptr
        if self._pos is not None:
            set_array_base(self._pos, self.holder)
            self._pos.data = <char*>&self.data[0].pos
        if self._velocity is not None:
            set_array_base(self._velocity, self.holder)
            self._velocity.data = <char*>&self.data[0].velocity
        if self._rotation is not None:
            set_array_base(self._rotation, self.holder)
            self._rotation.data = <char*>&self.data[0].rotation
        if self._start_pos is not None:
            set_array_base(self._start_pos, self.holder)
            self._start_pos.data = <char*>&self.data[0].start_pos
        if self._dest_pos is not None:
            set_array_base(self._dest_pos, self.holder)
            self._dest_pos.data = <char*>&self.data[0].dest_pos
    def set_ptr(self, WrapAirshipData v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapHitPacketList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(HitPacketList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(HitPacketList))
    def cast(self, object klass):
        cdef WrapHitPacketList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapHitPacketList inst = WrapHitPacketList.__new__(WrapHitPacketList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(HitPacketList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef HitPacketList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(HitPacketList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(HitPacketList))
            return
        cdef HitPacketList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(HitPacketList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(HitPacketList))
        self._set_ptr(<HitPacketList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(HitPacketList))
        self._init_ptr(<HitPacketList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray8.__new__(WrapArray8)
        self._next.holder = self.holder
        self._next._init_ptr(&(<HitPacketList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray8.__new__(WrapArray8)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<HitPacketList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapHitPacket.__new__(WrapHitPacket)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapHitPacket v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, HitPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, HitPacketList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<HitPacketList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<HitPacketList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapHitPacketList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapParticleDataList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ParticleDataList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ParticleDataList))
    def cast(self, object klass):
        cdef WrapParticleDataList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapParticleDataList inst = WrapParticleDataList.__new__(WrapParticleDataList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ParticleDataList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ParticleDataList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ParticleDataList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ParticleDataList))
            return
        cdef ParticleDataList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ParticleDataList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ParticleDataList))
        self._set_ptr(<ParticleDataList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ParticleDataList))
        self._init_ptr(<ParticleDataList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray9.__new__(WrapArray9)
        self._next.holder = self.holder
        self._next._init_ptr(&(<ParticleDataList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray9.__new__(WrapArray9)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<ParticleDataList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapParticleData.__new__(WrapParticleData)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapParticleData v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ParticleDataList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ParticleDataList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<ParticleDataList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<ParticleDataList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapParticleDataList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapSoundActionList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(SoundActionList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(SoundActionList))
    def cast(self, object klass):
        cdef WrapSoundActionList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapSoundActionList inst = WrapSoundActionList.__new__(WrapSoundActionList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(SoundActionList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef SoundActionList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(SoundActionList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(SoundActionList))
            return
        cdef SoundActionList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(SoundActionList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SoundActionList))
        self._set_ptr(<SoundActionList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(SoundActionList))
        self._init_ptr(<SoundActionList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray10.__new__(WrapArray10)
        self._next.holder = self.holder
        self._next._init_ptr(&(<SoundActionList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray10.__new__(WrapArray10)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<SoundActionList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapSoundAction.__new__(WrapSoundAction)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapSoundAction v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, SoundActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, SoundActionList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<SoundActionList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<SoundActionList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapSoundActionList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapBlockActionList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(BlockActionList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(BlockActionList))
    def cast(self, object klass):
        cdef WrapBlockActionList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapBlockActionList inst = WrapBlockActionList.__new__(WrapBlockActionList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(BlockActionList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef BlockActionList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(BlockActionList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(BlockActionList))
            return
        cdef BlockActionList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(BlockActionList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(BlockActionList))
        self._set_ptr(<BlockActionList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(BlockActionList))
        self._init_ptr(<BlockActionList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray11.__new__(WrapArray11)
        self._next.holder = self.holder
        self._next._init_ptr(&(<BlockActionList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray11.__new__(WrapArray11)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<BlockActionList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapBlockAction.__new__(WrapBlockAction)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapBlockAction v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, BlockActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, BlockActionList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<BlockActionList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<BlockActionList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapBlockActionList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapShootPacketList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ShootPacketList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ShootPacketList))
    def cast(self, object klass):
        cdef WrapShootPacketList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapShootPacketList inst = WrapShootPacketList.__new__(WrapShootPacketList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ShootPacketList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ShootPacketList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ShootPacketList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ShootPacketList))
            return
        cdef ShootPacketList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ShootPacketList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ShootPacketList))
        self._set_ptr(<ShootPacketList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ShootPacketList))
        self._init_ptr(<ShootPacketList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray12.__new__(WrapArray12)
        self._next.holder = self.holder
        self._next._init_ptr(&(<ShootPacketList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray12.__new__(WrapArray12)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<ShootPacketList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapShootPacket.__new__(WrapShootPacket)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapShootPacket v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ShootPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ShootPacketList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<ShootPacketList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<ShootPacketList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapShootPacketList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapChunkItemList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ChunkItemList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ChunkItemList))
    def cast(self, object klass):
        cdef WrapChunkItemList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapChunkItemList inst = WrapChunkItemList.__new__(WrapChunkItemList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ChunkItemList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ChunkItemList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ChunkItemList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ChunkItemList))
            return
        cdef ChunkItemList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ChunkItemList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemList))
        self._set_ptr(<ChunkItemList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemList))
        self._init_ptr(<ChunkItemList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray13.__new__(WrapArray13)
        self._next.holder = self.holder
        self._next._init_ptr(&(<ChunkItemList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray13.__new__(WrapArray13)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<ChunkItemList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapChunkItemData.__new__(WrapChunkItemData)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapChunkItemData v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ChunkItemList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ChunkItemList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<ChunkItemList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<ChunkItemList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapChunkItemList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapChunkItemsList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ChunkItemsList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ChunkItemsList))
    def cast(self, object klass):
        cdef WrapChunkItemsList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapChunkItemsList inst = WrapChunkItemsList.__new__(WrapChunkItemsList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ChunkItemsList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef ChunkItemsList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(ChunkItemsList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(ChunkItemsList))
            return
        cdef ChunkItemsList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(ChunkItemsList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemsList))
        self._set_ptr(<ChunkItemsList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(ChunkItemsList))
        self._init_ptr(<ChunkItemsList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray14.__new__(WrapArray14)
        self._next.holder = self.holder
        self._next._init_ptr(&(<ChunkItemsList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray14.__new__(WrapArray14)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<ChunkItemsList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def chunk_x(self):
        return self.data[0].chunk_x
    @chunk_x.setter
    def chunk_x(self, value):
        self.data[0].chunk_x = value
    @property
    def chunk_y(self):
        return self.data[0].chunk_y
    @chunk_y.setter
    def chunk_y(self, value):
        self.data[0].chunk_y = value
    @property
    def data(self):
        if self.data[0].data == 0:
            return None
        if self._data is not None:
            return self._data
        self._data = WrapArray13.__new__(WrapArray13)
        self._data.holder = self.holder
        self._data._init_ptr(&(<ChunkItemList*>self.data[0].data)[0])
        return self._data
    @data.setter
    def data(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, ChunkItemsList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ChunkItemsList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<ChunkItemsList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<ChunkItemsList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&(<ChunkItemList*>self.data[0].data)[0])
    def set_ptr(self, WrapChunkItemsList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapStaticEntityList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(StaticEntityList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(StaticEntityList))
    def cast(self, object klass):
        cdef WrapStaticEntityList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapStaticEntityList inst = WrapStaticEntityList.__new__(WrapStaticEntityList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(StaticEntityList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef StaticEntityList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(StaticEntityList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(StaticEntityList))
            return
        cdef StaticEntityList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(StaticEntityList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntityList))
        self._set_ptr(<StaticEntityList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(StaticEntityList))
        self._init_ptr(<StaticEntityList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray15.__new__(WrapArray15)
        self._next.holder = self.holder
        self._next._init_ptr(&(<StaticEntityList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray15.__new__(WrapArray15)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<StaticEntityList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapStaticEntityHeader.__new__(WrapStaticEntityHeader)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapStaticEntityHeader v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, StaticEntityList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, StaticEntityList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<StaticEntityList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<StaticEntityList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapStaticEntityList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItems8List_2:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Items8List_2))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Items8List_2))
    def cast(self, object klass):
        cdef WrapItems8List_2 c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItems8List_2 inst = WrapItems8List_2.__new__(WrapItems8List_2)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Items8List_2))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Items8List_2 * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Items8List_2))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Items8List_2))
            return
        cdef Items8List_2 * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Items8List_2))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Items8List_2))
        self._set_ptr(<Items8List_2*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Items8List_2))
        self._init_ptr(<Items8List_2*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray16.__new__(WrapArray16)
        self._next.holder = self.holder
        self._next._init_ptr(&(<Items8List_2*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray16.__new__(WrapArray16)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<Items8List_2*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = <uint8_t[:16]>(&self.data[0].data[0])
        return self._data
    @data.setter
    def data(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Items8List_2 * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Items8List_2 * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<Items8List_2*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<Items8List_2*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.data = <char*>(&self.data[0].data[0])
    def set_ptr(self, WrapItems8List_2 v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapItems8List_1:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Items8List_1))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Items8List_1))
    def cast(self, object klass):
        cdef WrapItems8List_1 c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapItems8List_1 inst = WrapItems8List_1.__new__(WrapItems8List_1)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Items8List_1))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef Items8List_1 * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(Items8List_1))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(Items8List_1))
            return
        cdef Items8List_1 * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(Items8List_1))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Items8List_1))
        self._set_ptr(<Items8List_1*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(Items8List_1))
        self._init_ptr(<Items8List_1*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray17.__new__(WrapArray17)
        self._next.holder = self.holder
        self._next._init_ptr(&(<Items8List_1*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray17.__new__(WrapArray17)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<Items8List_1*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def something(self):
        return self.data[0].something
    @something.setter
    def something(self, value):
        self.data[0].something = value
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapItems8List_2.__new__(WrapItems8List_2)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapItems8List_2 v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, Items8List_1 * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Items8List_1 * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<Items8List_1*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<Items8List_1*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapItems8List_1 v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapPickupActionList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(PickupActionList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(PickupActionList))
    def cast(self, object klass):
        cdef WrapPickupActionList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapPickupActionList inst = WrapPickupActionList.__new__(WrapPickupActionList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(PickupActionList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef PickupActionList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(PickupActionList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(PickupActionList))
            return
        cdef PickupActionList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(PickupActionList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PickupActionList))
        self._set_ptr(<PickupActionList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PickupActionList))
        self._init_ptr(<PickupActionList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray18.__new__(WrapArray18)
        self._next.holder = self.holder
        self._next._init_ptr(&(<PickupActionList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray18.__new__(WrapArray18)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<PickupActionList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapPickupAction.__new__(WrapPickupAction)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapPickupAction v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, PickupActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PickupActionList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<PickupActionList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<PickupActionList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapPickupActionList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapKillActionList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(KillActionList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(KillActionList))
    def cast(self, object klass):
        cdef WrapKillActionList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapKillActionList inst = WrapKillActionList.__new__(WrapKillActionList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(KillActionList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef KillActionList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(KillActionList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(KillActionList))
            return
        cdef KillActionList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(KillActionList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(KillActionList))
        self._set_ptr(<KillActionList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(KillActionList))
        self._init_ptr(<KillActionList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray19.__new__(WrapArray19)
        self._next.holder = self.holder
        self._next._init_ptr(&(<KillActionList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray19.__new__(WrapArray19)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<KillActionList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapKillAction.__new__(WrapKillAction)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapKillAction v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, KillActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, KillActionList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<KillActionList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<KillActionList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapKillActionList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapDamageActionList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(DamageActionList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(DamageActionList))
    def cast(self, object klass):
        cdef WrapDamageActionList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapDamageActionList inst = WrapDamageActionList.__new__(WrapDamageActionList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(DamageActionList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef DamageActionList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(DamageActionList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(DamageActionList))
            return
        cdef DamageActionList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(DamageActionList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(DamageActionList))
        self._set_ptr(<DamageActionList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(DamageActionList))
        self._init_ptr(<DamageActionList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray20.__new__(WrapArray20)
        self._next.holder = self.holder
        self._next._init_ptr(&(<DamageActionList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray20.__new__(WrapArray20)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<DamageActionList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapDamageAction.__new__(WrapDamageAction)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapDamageAction v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, DamageActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, DamageActionList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<DamageActionList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<DamageActionList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapDamageActionList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapPassivePacketList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(PassivePacketList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(PassivePacketList))
    def cast(self, object klass):
        cdef WrapPassivePacketList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapPassivePacketList inst = WrapPassivePacketList.__new__(WrapPassivePacketList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(PassivePacketList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef PassivePacketList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(PassivePacketList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(PassivePacketList))
            return
        cdef PassivePacketList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(PassivePacketList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PassivePacketList))
        self._set_ptr(<PassivePacketList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PassivePacketList))
        self._init_ptr(<PassivePacketList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray21.__new__(WrapArray21)
        self._next.holder = self.holder
        self._next._init_ptr(&(<PassivePacketList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray21.__new__(WrapArray21)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<PassivePacketList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapPassivePacket.__new__(WrapPassivePacket)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapPassivePacket v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, PassivePacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PassivePacketList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<PassivePacketList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<PassivePacketList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapPassivePacketList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapMissionPacketList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(MissionPacketList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(MissionPacketList))
    def cast(self, object klass):
        cdef WrapMissionPacketList c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapMissionPacketList inst = WrapMissionPacketList.__new__(WrapMissionPacketList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(MissionPacketList))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef MissionPacketList * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(MissionPacketList))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(MissionPacketList))
            return
        cdef MissionPacketList * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(MissionPacketList))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionPacketList))
        self._set_ptr(<MissionPacketList*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(MissionPacketList))
        self._init_ptr(<MissionPacketList*>buf)
    @property
    def next(self):
        if self.data[0].next == 0:
            return None
        if self._next is not None:
            return self._next
        self._next = WrapArray22.__new__(WrapArray22)
        self._next.holder = self.holder
        self._next._init_ptr(&(<MissionPacketList*>self.data[0].next)[0])
        return self._next
    @next.setter
    def next(self, value):
        raise NotImplementedError()
    @property
    def prev(self):
        if self.data[0].prev == 0:
            return None
        if self._prev is not None:
            return self._prev
        self._prev = WrapArray22.__new__(WrapArray22)
        self._prev.holder = self.holder
        self._prev._init_ptr(&(<MissionPacketList*>self.data[0].prev)[0])
        return self._prev
    @prev.setter
    def prev(self, value):
        raise NotImplementedError()
    @property
    def data(self):
        if self._data is not None:
            return self._data
        self._data = WrapMissionPacket.__new__(WrapMissionPacket)
        self._data.holder = self.holder
        self._data._init_ptr(&self.data[0].data)
        return self._data
    @data.setter
    def data(self, value):
        cdef WrapMissionPacket v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, MissionPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionPacketList * ptr):
        self.data = ptr
        if self._next is not None:
            self._next.holder = self.holder
            self._next._set_ptr(&(<MissionPacketList*>self.data[0].next)[0])
        if self._prev is not None:
            self._prev.holder = self.holder
            self._prev._set_ptr(&(<MissionPacketList*>self.data[0].prev)[0])
        if self._data is not None:
            self._data.holder = self.holder
            self._data._set_ptr(&self.data[0].data)
    def set_ptr(self, WrapMissionPacketList v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapPacketQueue:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(PacketQueue))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(PacketQueue))
    def cast(self, object klass):
        cdef WrapPacketQueue c = klass.__new__(klass)
        c.holder = self.holder
        c._init_ptr(self.data)
        return c
    def copy(self):
        cdef WrapPacketQueue inst = WrapPacketQueue.__new__(WrapPacketQueue)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(PacketQueue))
        return inst
    def __init__(self):
        self.alloc()

    def make_standalone_copy(self):
        if self.holder is not None:
            return
        cdef PacketQueue * old_data = self.data
        self.realloc()
        memcpy(self.data, old_data, sizeof(PacketQueue))
    def make_standalone_reset(self):
        if self.holder is not None:
            memset(self.data, 0, sizeof(PacketQueue))
            return
        cdef PacketQueue * old_data = self.data
        self.realloc()
        memset(self.data, 0, sizeof(PacketQueue))
    cdef void realloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PacketQueue))
        self._set_ptr(<PacketQueue*>buf)
    cdef void alloc(self):
        self.holder = MemoryHolder.__new__(MemoryHolder)
        cdef void * buf = self.holder.alloc(sizeof(PacketQueue))
        self._init_ptr(<PacketQueue*>buf)
    @property
    def player_hits(self):
        if self.data[0].player_hits == 0:
            return None
        if self._player_hits is not None:
            return self._player_hits
        self._player_hits = WrapArray8.__new__(WrapArray8)
        self._player_hits.holder = self.holder
        self._player_hits._init_ptr(&(<HitPacketList*>self.data[0].player_hits)[0])
        return self._player_hits
    @player_hits.setter
    def player_hits(self, value):
        raise NotImplementedError()
    @property
    def player_hits_size(self):
        return self.data[0].player_hits_size
    @player_hits_size.setter
    def player_hits_size(self, value):
        self.data[0].player_hits_size = value
    @property
    def sound_actions(self):
        if self.data[0].sound_actions == 0:
            return None
        if self._sound_actions is not None:
            return self._sound_actions
        self._sound_actions = WrapArray10.__new__(WrapArray10)
        self._sound_actions.holder = self.holder
        self._sound_actions._init_ptr(&(<SoundActionList*>self.data[0].sound_actions)[0])
        return self._sound_actions
    @sound_actions.setter
    def sound_actions(self, value):
        raise NotImplementedError()
    @property
    def sound_actions_size(self):
        return self.data[0].sound_actions_size
    @sound_actions_size.setter
    def sound_actions_size(self, value):
        self.data[0].sound_actions_size = value
    @property
    def particles(self):
        if self.data[0].particles == 0:
            return None
        if self._particles is not None:
            return self._particles
        self._particles = WrapArray9.__new__(WrapArray9)
        self._particles.holder = self.holder
        self._particles._init_ptr(&(<ParticleDataList*>self.data[0].particles)[0])
        return self._particles
    @particles.setter
    def particles(self, value):
        raise NotImplementedError()
    @property
    def particles_size(self):
        return self.data[0].particles_size
    @particles_size.setter
    def particles_size(self, value):
        self.data[0].particles_size = value
    @property
    def block_actions(self):
        if self.data[0].block_actions == 0:
            return None
        if self._block_actions is not None:
            return self._block_actions
        self._block_actions = WrapArray11.__new__(WrapArray11)
        self._block_actions.holder = self.holder
        self._block_actions._init_ptr(&(<BlockActionList*>self.data[0].block_actions)[0])
        return self._block_actions
    @block_actions.setter
    def block_actions(self, value):
        raise NotImplementedError()
    @property
    def block_actions_size(self):
        return self.data[0].block_actions_size
    @block_actions_size.setter
    def block_actions_size(self, value):
        self.data[0].block_actions_size = value
    @property
    def shoot_packets(self):
        if self.data[0].shoot_packets == 0:
            return None
        if self._shoot_packets is not None:
            return self._shoot_packets
        self._shoot_packets = WrapArray12.__new__(WrapArray12)
        self._shoot_packets.holder = self.holder
        self._shoot_packets._init_ptr(&(<ShootPacketList*>self.data[0].shoot_packets)[0])
        return self._shoot_packets
    @shoot_packets.setter
    def shoot_packets(self, value):
        raise NotImplementedError()
    @property
    def shoot_packets_size(self):
        return self.data[0].shoot_packets_size
    @shoot_packets_size.setter
    def shoot_packets_size(self, value):
        self.data[0].shoot_packets_size = value
    @property
    def chunk_items(self):
        if self.data[0].chunk_items == 0:
            return None
        if self._chunk_items is not None:
            return self._chunk_items
        self._chunk_items = WrapArray14.__new__(WrapArray14)
        self._chunk_items.holder = self.holder
        self._chunk_items._init_ptr(&(<ChunkItemsList*>self.data[0].chunk_items)[0])
        return self._chunk_items
    @chunk_items.setter
    def chunk_items(self, value):
        raise NotImplementedError()
    @property
    def chunk_items_size(self):
        return self.data[0].chunk_items_size
    @chunk_items_size.setter
    def chunk_items_size(self, value):
        self.data[0].chunk_items_size = value
    @property
    def static_entities(self):
        if self.data[0].static_entities == 0:
            return None
        if self._static_entities is not None:
            return self._static_entities
        self._static_entities = WrapArray15.__new__(WrapArray15)
        self._static_entities.holder = self.holder
        self._static_entities._init_ptr(&(<StaticEntityList*>self.data[0].static_entities)[0])
        return self._static_entities
    @static_entities.setter
    def static_entities(self, value):
        raise NotImplementedError()
    @property
    def static_entities_size(self):
        return self.data[0].static_entities_size
    @static_entities_size.setter
    def static_entities_size(self, value):
        self.data[0].static_entities_size = value
    @property
    def items_8(self):
        if self.data[0].items_8 == 0:
            return None
        if self._items_8 is not None:
            return self._items_8
        self._items_8 = WrapArray17.__new__(WrapArray17)
        self._items_8.holder = self.holder
        self._items_8._init_ptr(&(<Items8List_1*>self.data[0].items_8)[0])
        return self._items_8
    @items_8.setter
    def items_8(self, value):
        raise NotImplementedError()
    @property
    def items_8_size(self):
        return self.data[0].items_8_size
    @items_8_size.setter
    def items_8_size(self, value):
        self.data[0].items_8_size = value
    @property
    def pickup_actions(self):
        if self.data[0].pickup_actions == 0:
            return None
        if self._pickup_actions is not None:
            return self._pickup_actions
        self._pickup_actions = WrapArray18.__new__(WrapArray18)
        self._pickup_actions.holder = self.holder
        self._pickup_actions._init_ptr(&(<PickupActionList*>self.data[0].pickup_actions)[0])
        return self._pickup_actions
    @pickup_actions.setter
    def pickup_actions(self, value):
        raise NotImplementedError()
    @property
    def pickup_actions_size(self):
        return self.data[0].pickup_actions_size
    @pickup_actions_size.setter
    def pickup_actions_size(self, value):
        self.data[0].pickup_actions_size = value
    @property
    def kill_actions(self):
        if self.data[0].kill_actions == 0:
            return None
        if self._kill_actions is not None:
            return self._kill_actions
        self._kill_actions = WrapArray19.__new__(WrapArray19)
        self._kill_actions.holder = self.holder
        self._kill_actions._init_ptr(&(<KillActionList*>self.data[0].kill_actions)[0])
        return self._kill_actions
    @kill_actions.setter
    def kill_actions(self, value):
        raise NotImplementedError()
    @property
    def kill_actions_size(self):
        return self.data[0].kill_actions_size
    @kill_actions_size.setter
    def kill_actions_size(self, value):
        self.data[0].kill_actions_size = value
    @property
    def damage_actions(self):
        if self.data[0].damage_actions == 0:
            return None
        if self._damage_actions is not None:
            return self._damage_actions
        self._damage_actions = WrapArray20.__new__(WrapArray20)
        self._damage_actions.holder = self.holder
        self._damage_actions._init_ptr(&(<DamageActionList*>self.data[0].damage_actions)[0])
        return self._damage_actions
    @damage_actions.setter
    def damage_actions(self, value):
        raise NotImplementedError()
    @property
    def damage_actions_size(self):
        return self.data[0].damage_actions_size
    @damage_actions_size.setter
    def damage_actions_size(self, value):
        self.data[0].damage_actions_size = value
    @property
    def passive_packets(self):
        if self.data[0].passive_packets == 0:
            return None
        if self._passive_packets is not None:
            return self._passive_packets
        self._passive_packets = WrapArray21.__new__(WrapArray21)
        self._passive_packets.holder = self.holder
        self._passive_packets._init_ptr(&(<PassivePacketList*>self.data[0].passive_packets)[0])
        return self._passive_packets
    @passive_packets.setter
    def passive_packets(self, value):
        raise NotImplementedError()
    @property
    def passive_packets_size(self):
        return self.data[0].passive_packets_size
    @passive_packets_size.setter
    def passive_packets_size(self, value):
        self.data[0].passive_packets_size = value
    @property
    def missions(self):
        if self.data[0].missions == 0:
            return None
        if self._missions is not None:
            return self._missions
        self._missions = WrapArray22.__new__(WrapArray22)
        self._missions.holder = self.holder
        self._missions._init_ptr(&(<MissionPacketList*>self.data[0].missions)[0])
        return self._missions
    @missions.setter
    def missions(self, value):
        raise NotImplementedError()
    @property
    def missions_size(self):
        return self.data[0].missions_size
    @missions_size.setter
    def missions_size(self, value):
        self.data[0].missions_size = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
    cdef void _init_ptr(self, PacketQueue * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PacketQueue * ptr):
        self.data = ptr
        if self._player_hits is not None:
            self._player_hits.holder = self.holder
            self._player_hits._set_ptr(&(<HitPacketList*>self.data[0].player_hits)[0])
        if self._sound_actions is not None:
            self._sound_actions.holder = self.holder
            self._sound_actions._set_ptr(&(<SoundActionList*>self.data[0].sound_actions)[0])
        if self._particles is not None:
            self._particles.holder = self.holder
            self._particles._set_ptr(&(<ParticleDataList*>self.data[0].particles)[0])
        if self._block_actions is not None:
            self._block_actions.holder = self.holder
            self._block_actions._set_ptr(&(<BlockActionList*>self.data[0].block_actions)[0])
        if self._shoot_packets is not None:
            self._shoot_packets.holder = self.holder
            self._shoot_packets._set_ptr(&(<ShootPacketList*>self.data[0].shoot_packets)[0])
        if self._chunk_items is not None:
            self._chunk_items.holder = self.holder
            self._chunk_items._set_ptr(&(<ChunkItemsList*>self.data[0].chunk_items)[0])
        if self._static_entities is not None:
            self._static_entities.holder = self.holder
            self._static_entities._set_ptr(&(<StaticEntityList*>self.data[0].static_entities)[0])
        if self._items_8 is not None:
            self._items_8.holder = self.holder
            self._items_8._set_ptr(&(<Items8List_1*>self.data[0].items_8)[0])
        if self._pickup_actions is not None:
            self._pickup_actions.holder = self.holder
            self._pickup_actions._set_ptr(&(<PickupActionList*>self.data[0].pickup_actions)[0])
        if self._kill_actions is not None:
            self._kill_actions.holder = self.holder
            self._kill_actions._set_ptr(&(<KillActionList*>self.data[0].kill_actions)[0])
        if self._damage_actions is not None:
            self._damage_actions.holder = self.holder
            self._damage_actions._set_ptr(&(<DamageActionList*>self.data[0].damage_actions)[0])
        if self._passive_packets is not None:
            self._passive_packets.holder = self.holder
            self._passive_packets._set_ptr(&(<PassivePacketList*>self.data[0].passive_packets)[0])
        if self._missions is not None:
            self._missions.holder = self.holder
            self._missions._set_ptr(&(<MissionPacketList*>self.data[0].missions)[0])
    def set_ptr(self, WrapPacketQueue v):
        self.holder = v.holder
        self._set_ptr(v.data)
cdef class WrapArray0:
    def __getitem__(self, uint32_t index):
        if index >= 32: raise IndexError()
        if index == 0: return self._data0
        if index == 1: return self._data1
        if index == 2: return self._data2
        if index == 3: return self._data3
        if index == 4: return self._data4
        if index == 5: return self._data5
        if index == 6: return self._data6
        if index == 7: return self._data7
        if index == 8: return self._data8
        if index == 9: return self._data9
        if index == 10: return self._data10
        if index == 11: return self._data11
        if index == 12: return self._data12
        if index == 13: return self._data13
        if index == 14: return self._data14
        if index == 15: return self._data15
        if index == 16: return self._data16
        if index == 17: return self._data17
        if index == 18: return self._data18
        if index == 19: return self._data19
        if index == 20: return self._data20
        if index == 21: return self._data21
        if index == 22: return self._data22
        if index == 23: return self._data23
        if index == 24: return self._data24
        if index == 25: return self._data25
        if index == 26: return self._data26
        if index == 27: return self._data27
        if index == 28: return self._data28
        if index == 29: return self._data29
        if index == 30: return self._data30
        if index == 31: return self._data31
    cdef void _init_ptr(self, ItemUpgrade * ptr):
        self._data0 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data0.holder = self.holder
        self._data0._init_ptr(&ptr[0])
        self._data1 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data1.holder = self.holder
        self._data1._init_ptr(&ptr[1])
        self._data2 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data2.holder = self.holder
        self._data2._init_ptr(&ptr[2])
        self._data3 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data3.holder = self.holder
        self._data3._init_ptr(&ptr[3])
        self._data4 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data4.holder = self.holder
        self._data4._init_ptr(&ptr[4])
        self._data5 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data5.holder = self.holder
        self._data5._init_ptr(&ptr[5])
        self._data6 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data6.holder = self.holder
        self._data6._init_ptr(&ptr[6])
        self._data7 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data7.holder = self.holder
        self._data7._init_ptr(&ptr[7])
        self._data8 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data8.holder = self.holder
        self._data8._init_ptr(&ptr[8])
        self._data9 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data9.holder = self.holder
        self._data9._init_ptr(&ptr[9])
        self._data10 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data10.holder = self.holder
        self._data10._init_ptr(&ptr[10])
        self._data11 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data11.holder = self.holder
        self._data11._init_ptr(&ptr[11])
        self._data12 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data12.holder = self.holder
        self._data12._init_ptr(&ptr[12])
        self._data13 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data13.holder = self.holder
        self._data13._init_ptr(&ptr[13])
        self._data14 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data14.holder = self.holder
        self._data14._init_ptr(&ptr[14])
        self._data15 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data15.holder = self.holder
        self._data15._init_ptr(&ptr[15])
        self._data16 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data16.holder = self.holder
        self._data16._init_ptr(&ptr[16])
        self._data17 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data17.holder = self.holder
        self._data17._init_ptr(&ptr[17])
        self._data18 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data18.holder = self.holder
        self._data18._init_ptr(&ptr[18])
        self._data19 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data19.holder = self.holder
        self._data19._init_ptr(&ptr[19])
        self._data20 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data20.holder = self.holder
        self._data20._init_ptr(&ptr[20])
        self._data21 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data21.holder = self.holder
        self._data21._init_ptr(&ptr[21])
        self._data22 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data22.holder = self.holder
        self._data22._init_ptr(&ptr[22])
        self._data23 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data23.holder = self.holder
        self._data23._init_ptr(&ptr[23])
        self._data24 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data24.holder = self.holder
        self._data24._init_ptr(&ptr[24])
        self._data25 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data25.holder = self.holder
        self._data25._init_ptr(&ptr[25])
        self._data26 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data26.holder = self.holder
        self._data26._init_ptr(&ptr[26])
        self._data27 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data27.holder = self.holder
        self._data27._init_ptr(&ptr[27])
        self._data28 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data28.holder = self.holder
        self._data28._init_ptr(&ptr[28])
        self._data29 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data29.holder = self.holder
        self._data29._init_ptr(&ptr[29])
        self._data30 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data30.holder = self.holder
        self._data30._init_ptr(&ptr[30])
        self._data31 = WrapItemUpgrade.__new__(WrapItemUpgrade)
        self._data31.holder = self.holder
        self._data31._init_ptr(&ptr[31])
    cdef void _set_ptr(self, ItemUpgrade * ptr):
        self._data0._set_ptr(&ptr[0])
        self._data1._set_ptr(&ptr[1])
        self._data2._set_ptr(&ptr[2])
        self._data3._set_ptr(&ptr[3])
        self._data4._set_ptr(&ptr[4])
        self._data5._set_ptr(&ptr[5])
        self._data6._set_ptr(&ptr[6])
        self._data7._set_ptr(&ptr[7])
        self._data8._set_ptr(&ptr[8])
        self._data9._set_ptr(&ptr[9])
        self._data10._set_ptr(&ptr[10])
        self._data11._set_ptr(&ptr[11])
        self._data12._set_ptr(&ptr[12])
        self._data13._set_ptr(&ptr[13])
        self._data14._set_ptr(&ptr[14])
        self._data15._set_ptr(&ptr[15])
        self._data16._set_ptr(&ptr[16])
        self._data17._set_ptr(&ptr[17])
        self._data18._set_ptr(&ptr[18])
        self._data19._set_ptr(&ptr[19])
        self._data20._set_ptr(&ptr[20])
        self._data21._set_ptr(&ptr[21])
        self._data22._set_ptr(&ptr[22])
        self._data23._set_ptr(&ptr[23])
        self._data24._set_ptr(&ptr[24])
        self._data25._set_ptr(&ptr[25])
        self._data26._set_ptr(&ptr[26])
        self._data27._set_ptr(&ptr[27])
        self._data28._set_ptr(&ptr[28])
        self._data29._set_ptr(&ptr[29])
        self._data30._set_ptr(&ptr[30])
        self._data31._set_ptr(&ptr[31])
    def __len__(self):
        return 32
cdef class WrapArray1:
    def __getitem__(self, uint32_t index):
        if index >= 13: raise IndexError()
        if index == 0: return self._data0
        if index == 1: return self._data1
        if index == 2: return self._data2
        if index == 3: return self._data3
        if index == 4: return self._data4
        if index == 5: return self._data5
        if index == 6: return self._data6
        if index == 7: return self._data7
        if index == 8: return self._data8
        if index == 9: return self._data9
        if index == 10: return self._data10
        if index == 11: return self._data11
        if index == 12: return self._data12
    cdef void _init_ptr(self, ItemData * ptr):
        self._data0 = WrapItemData.__new__(WrapItemData)
        self._data0.holder = self.holder
        self._data0._init_ptr(&ptr[0])
        self._data1 = WrapItemData.__new__(WrapItemData)
        self._data1.holder = self.holder
        self._data1._init_ptr(&ptr[1])
        self._data2 = WrapItemData.__new__(WrapItemData)
        self._data2.holder = self.holder
        self._data2._init_ptr(&ptr[2])
        self._data3 = WrapItemData.__new__(WrapItemData)
        self._data3.holder = self.holder
        self._data3._init_ptr(&ptr[3])
        self._data4 = WrapItemData.__new__(WrapItemData)
        self._data4.holder = self.holder
        self._data4._init_ptr(&ptr[4])
        self._data5 = WrapItemData.__new__(WrapItemData)
        self._data5.holder = self.holder
        self._data5._init_ptr(&ptr[5])
        self._data6 = WrapItemData.__new__(WrapItemData)
        self._data6.holder = self.holder
        self._data6._init_ptr(&ptr[6])
        self._data7 = WrapItemData.__new__(WrapItemData)
        self._data7.holder = self.holder
        self._data7._init_ptr(&ptr[7])
        self._data8 = WrapItemData.__new__(WrapItemData)
        self._data8.holder = self.holder
        self._data8._init_ptr(&ptr[8])
        self._data9 = WrapItemData.__new__(WrapItemData)
        self._data9.holder = self.holder
        self._data9._init_ptr(&ptr[9])
        self._data10 = WrapItemData.__new__(WrapItemData)
        self._data10.holder = self.holder
        self._data10._init_ptr(&ptr[10])
        self._data11 = WrapItemData.__new__(WrapItemData)
        self._data11.holder = self.holder
        self._data11._init_ptr(&ptr[11])
        self._data12 = WrapItemData.__new__(WrapItemData)
        self._data12.holder = self.holder
        self._data12._init_ptr(&ptr[12])
    cdef void _set_ptr(self, ItemData * ptr):
        self._data0._set_ptr(&ptr[0])
        self._data1._set_ptr(&ptr[1])
        self._data2._set_ptr(&ptr[2])
        self._data3._set_ptr(&ptr[3])
        self._data4._set_ptr(&ptr[4])
        self._data5._set_ptr(&ptr[5])
        self._data6._set_ptr(&ptr[6])
        self._data7._set_ptr(&ptr[7])
        self._data8._set_ptr(&ptr[8])
        self._data9._set_ptr(&ptr[9])
        self._data10._set_ptr(&ptr[10])
        self._data11._set_ptr(&ptr[11])
        self._data12._set_ptr(&ptr[12])
    def __len__(self):
        return 13
cdef class WrapArray2:
    def __getitem__(self, uint32_t index):
        return self.data[index]
    cdef void _init_ptr(self, int8_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, int8_t * ptr):
        self.data = ptr
cdef class WrapArray3:
    def __getitem__(self, uint32_t index):
        cdef WrapColor ret = WrapColor.__new__(WrapColor)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, Color * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Color * ptr):
        self.data = ptr
cdef class WrapArray4:
    def __getitem__(self, uint32_t index):
        cdef WrapField ret = WrapField.__new__(WrapField)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, Field * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Field * ptr):
        self.data = ptr
cdef class WrapArray5:
    def __getitem__(self, uint32_t index):
        if index >= 4096: raise IndexError()
        cdef WrapRegionSomething ret = WrapRegionSomething.__new__(WrapRegionSomething)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, RegionSomething * ptr):
        self.data = ptr
    cdef void _set_ptr(self, RegionSomething * ptr):
        self.data = ptr
    def __len__(self):
        return 4096
cdef class WrapArray6:
    def __getitem__(self, uint32_t index):
        if index >= 4096: raise IndexError()
        if self.data[index] == 0: return None
        cdef WrapZone ret = WrapZone.__new__(WrapZone)
        ret.holder = self.holder
        ret._init_ptr(<Zone*>self.data[index])
        return ret
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def __len__(self):
        return 4096
cdef class WrapArray7:
    def __getitem__(self, uint32_t index):
        if index >= 64: raise IndexError()
        cdef WrapMissionData ret = WrapMissionData.__new__(WrapMissionData)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, MissionData * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionData * ptr):
        self.data = ptr
    def __len__(self):
        return 64
cdef class WrapArray8:
    def __getitem__(self, uint32_t index):
        cdef WrapHitPacketList ret = WrapHitPacketList.__new__(WrapHitPacketList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, HitPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, HitPacketList * ptr):
        self.data = ptr
cdef class WrapArray9:
    def __getitem__(self, uint32_t index):
        cdef WrapParticleDataList ret = WrapParticleDataList.__new__(WrapParticleDataList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, ParticleDataList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ParticleDataList * ptr):
        self.data = ptr
cdef class WrapArray10:
    def __getitem__(self, uint32_t index):
        cdef WrapSoundActionList ret = WrapSoundActionList.__new__(WrapSoundActionList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, SoundActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, SoundActionList * ptr):
        self.data = ptr
cdef class WrapArray11:
    def __getitem__(self, uint32_t index):
        cdef WrapBlockActionList ret = WrapBlockActionList.__new__(WrapBlockActionList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, BlockActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, BlockActionList * ptr):
        self.data = ptr
cdef class WrapArray12:
    def __getitem__(self, uint32_t index):
        cdef WrapShootPacketList ret = WrapShootPacketList.__new__(WrapShootPacketList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, ShootPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ShootPacketList * ptr):
        self.data = ptr
cdef class WrapArray13:
    def __getitem__(self, uint32_t index):
        cdef WrapChunkItemList ret = WrapChunkItemList.__new__(WrapChunkItemList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, ChunkItemList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ChunkItemList * ptr):
        self.data = ptr
cdef class WrapArray14:
    def __getitem__(self, uint32_t index):
        cdef WrapChunkItemsList ret = WrapChunkItemsList.__new__(WrapChunkItemsList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, ChunkItemsList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, ChunkItemsList * ptr):
        self.data = ptr
cdef class WrapArray15:
    def __getitem__(self, uint32_t index):
        cdef WrapStaticEntityList ret = WrapStaticEntityList.__new__(WrapStaticEntityList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, StaticEntityList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, StaticEntityList * ptr):
        self.data = ptr
cdef class WrapArray16:
    def __getitem__(self, uint32_t index):
        cdef WrapItems8List_2 ret = WrapItems8List_2.__new__(WrapItems8List_2)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, Items8List_2 * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Items8List_2 * ptr):
        self.data = ptr
cdef class WrapArray17:
    def __getitem__(self, uint32_t index):
        cdef WrapItems8List_1 ret = WrapItems8List_1.__new__(WrapItems8List_1)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, Items8List_1 * ptr):
        self.data = ptr
    cdef void _set_ptr(self, Items8List_1 * ptr):
        self.data = ptr
cdef class WrapArray18:
    def __getitem__(self, uint32_t index):
        cdef WrapPickupActionList ret = WrapPickupActionList.__new__(WrapPickupActionList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, PickupActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PickupActionList * ptr):
        self.data = ptr
cdef class WrapArray19:
    def __getitem__(self, uint32_t index):
        cdef WrapKillActionList ret = WrapKillActionList.__new__(WrapKillActionList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, KillActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, KillActionList * ptr):
        self.data = ptr
cdef class WrapArray20:
    def __getitem__(self, uint32_t index):
        cdef WrapDamageActionList ret = WrapDamageActionList.__new__(WrapDamageActionList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, DamageActionList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, DamageActionList * ptr):
        self.data = ptr
cdef class WrapArray21:
    def __getitem__(self, uint32_t index):
        cdef WrapPassivePacketList ret = WrapPassivePacketList.__new__(WrapPassivePacketList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, PassivePacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, PassivePacketList * ptr):
        self.data = ptr
cdef class WrapArray22:
    def __getitem__(self, uint32_t index):
        cdef WrapMissionPacketList ret = WrapMissionPacketList.__new__(WrapMissionPacketList)
        ret.holder = self.holder
        ret._init_ptr(&self.data[index])
        return ret
    cdef void _init_ptr(self, MissionPacketList * ptr):
        self.data = ptr
    cdef void _set_ptr(self, MissionPacketList * ptr):
        self.data = ptr
cdef class WrapItemWithHeaderVec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ItemWithHeader) * index
        if val >= end: raise IndexError()
        cdef ItemWithHeader * res = <ItemWithHeader*>val
        cdef WrapItemWithHeader ret = WrapItemWithHeader.__new__(WrapItemWithHeader)
        ret.holder = self.holder
        ret._init_ptr(&res[0])
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ItemWithHeader)
cdef class WrapItemWithHeaderListVec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ItemWithHeaderList) * index
        if val >= end: raise IndexError()
        cdef ItemWithHeaderList * res = <ItemWithHeaderList*>val
        cdef WrapItemWithHeaderList ret = WrapItemWithHeaderList.__new__(WrapItemWithHeaderList)
        ret.holder = self.holder
        ret._init_ptr(&res[0])
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ItemWithHeaderList)
cdef class Wrapuint8Vec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(uint8_t) * index
        if val >= end: raise IndexError()
        cdef uint8_t * res = <uint8_t*>val
        return res[0]
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(uint8_t)
cdef class WrapStaticEntityVec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(StaticEntity) * index
        if val >= end: raise IndexError()
        cdef StaticEntity * res = <StaticEntity*>val
        cdef WrapStaticEntity ret = WrapStaticEntity.__new__(WrapStaticEntity)
        ret.holder = self.holder
        ret._init_ptr(&res[0])
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(StaticEntity)
cdef class WrapSpawnPtrVec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(uint32_t) * index
        if val >= end: raise IndexError()
        cdef Spawn * res = <Spawn*>(<uint32_t*>val)[0]
        cdef WrapSpawn ret = WrapSpawn.__new__(WrapSpawn)
        ret.holder = self.holder
        ret._init_ptr(&res[0])
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(uint32_t)
cdef class WrapChunkItemDataVec:
    cdef void _init_ptr(self, uint32_t * ptr):
        self.data = ptr
    cdef void _set_ptr(self, uint32_t * ptr):
        self.data = ptr
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ChunkItemData) * index
        if val >= end: raise IndexError()
        cdef ChunkItemData * res = <ChunkItemData*>val
        cdef WrapChunkItemData ret = WrapChunkItemData.__new__(WrapChunkItemData)
        ret.holder = self.holder
        ret._init_ptr(&res[0])
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ChunkItemData)
cpdef inline bint is_pos_set(uint64_t mask):
    return mask & (<uint64_t>1 << 0) != 0


cpdef inline bint is_orient_set(uint64_t mask):
    return mask & (<uint64_t>1 << 1) != 0


cpdef inline bint is_vel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 2) != 0


cpdef inline bint is_accel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 3) != 0


cpdef inline bint is_extra_vel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 4) != 0


cpdef inline bint is_look_pitch_set(uint64_t mask):
    return mask & (<uint64_t>1 << 5) != 0


cpdef inline bint is_physics_set(uint64_t mask):
    return mask & (<uint64_t>1 << 6) != 0


cpdef inline bint is_hostile_set(uint64_t mask):
    return mask & (<uint64_t>1 << 7) != 0


cpdef inline bint is_type_set(uint64_t mask):
    return mask & (<uint64_t>1 << 8) != 0


cpdef inline bint is_mode_set(uint64_t mask):
    return mask & (<uint64_t>1 << 9) != 0


cpdef inline bint is_mode_time_set(uint64_t mask):
    return mask & (<uint64_t>1 << 10) != 0


cpdef inline bint is_hit_counter_set(uint64_t mask):
    return mask & (<uint64_t>1 << 11) != 0


cpdef inline bint is_last_hit_set(uint64_t mask):
    return mask & (<uint64_t>1 << 12) != 0


cpdef inline bint is_appearance_set(uint64_t mask):
    return mask & (<uint64_t>1 << 13) != 0


cpdef inline bint is_flags_set(uint64_t mask):
    return mask & (<uint64_t>1 << 14) != 0


cpdef inline bint is_roll_set(uint64_t mask):
    return mask & (<uint64_t>1 << 15) != 0


cpdef inline bint is_stun_set(uint64_t mask):
    return mask & (<uint64_t>1 << 16) != 0


cpdef inline bint is_slowed_set(uint64_t mask):
    return mask & (<uint64_t>1 << 17) != 0


cpdef inline bint is_make_blue_set(uint64_t mask):
    return mask & (<uint64_t>1 << 18) != 0


cpdef inline bint is_speed_up_set(uint64_t mask):
    return mask & (<uint64_t>1 << 19) != 0


cpdef inline bint is_show_patch_set(uint64_t mask):
    return mask & (<uint64_t>1 << 20) != 0


cpdef inline bint is_class_set(uint64_t mask):
    return mask & (<uint64_t>1 << 21) != 0


cpdef inline bint is_specialization_set(uint64_t mask):
    return mask & (<uint64_t>1 << 22) != 0


cpdef inline bint is_charged_mp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 23) != 0


cpdef inline bint is_ray_set(uint64_t mask):
    return mask & (<uint64_t>1 << 26) != 0


cpdef inline bint is_hp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 27) != 0


cpdef inline bint is_mp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 28) != 0


cpdef inline bint is_block_power_set(uint64_t mask):
    return mask & (<uint64_t>1 << 29) != 0


cpdef inline bint is_multiplier_set(uint64_t mask):
    return mask & (<uint64_t>1 << 30) != 0


cpdef inline bint is_level_set(uint64_t mask):
    return mask & (<uint64_t>1 << 33) != 0


cpdef inline bint is_xp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 34) != 0


cpdef inline bint is_owner_set(uint64_t mask):
    return mask & (<uint64_t>1 << 35) != 0


cpdef inline bint is_power_base_set(uint64_t mask):
    return mask & (<uint64_t>1 << 37) != 0


cpdef inline bint is_start_chunk_set(uint64_t mask):
    return mask & (<uint64_t>1 << 39) != 0


cpdef inline bint is_spawn_set(uint64_t mask):
    return mask & (<uint64_t>1 << 40) != 0


cpdef inline bint is_consumable_set(uint64_t mask):
    return mask & (<uint64_t>1 << 43) != 0


cpdef inline bint is_equipment_set(uint64_t mask):
    return mask & (<uint64_t>1 << 44) != 0


cpdef inline bint is_name_set(uint64_t mask):
    return mask & (<uint64_t>1 << 45) != 0


cpdef inline bint is_skill_set(uint64_t mask):
    return mask & (<uint64_t>1 << 46) != 0


cpdef inline bint is_mana_cubes_set(uint64_t mask):
    return mask & (<uint64_t>1 << 47) != 0


cpdef uint64_t read_masked_data(WrapEntityData entity, ByteReader reader):
    cdef bytes temp
    cdef char * tempc
    cdef uint64_t mask = reader.read_uint64()
    if mask & (<uint64_t>1 << 0) != 0:
        reader.read_c(&entity.data[0].pos, sizeof(entity.data[0].pos))
    if mask & (<uint64_t>1 << 1) != 0:
        reader.read_c(&entity.data[0].body_roll, sizeof(entity.data[0].body_roll))
        reader.read_c(&entity.data[0].body_pitch, sizeof(entity.data[0].body_pitch))
        reader.read_c(&entity.data[0].body_yaw, sizeof(entity.data[0].body_yaw))
    if mask & (<uint64_t>1 << 2) != 0:
        reader.read_c(&entity.data[0].velocity, sizeof(entity.data[0].velocity))
    if mask & (<uint64_t>1 << 3) != 0:
        reader.read_c(&entity.data[0].accel, sizeof(entity.data[0].accel))
    if mask & (<uint64_t>1 << 4) != 0:
        reader.read_c(&entity.data[0].extra_vel, sizeof(entity.data[0].extra_vel))
    if mask & (<uint64_t>1 << 5) != 0:
        reader.read_c(&entity.data[0].look_pitch, sizeof(entity.data[0].look_pitch))
    if mask & (<uint64_t>1 << 6) != 0:
        reader.read_c(&entity.data[0].physics_flags, sizeof(entity.data[0].physics_flags))
    if mask & (<uint64_t>1 << 7) != 0:
        reader.read_c(&entity.data[0].hostile_type, sizeof(entity.data[0].hostile_type))
    if mask & (<uint64_t>1 << 8) != 0:
        reader.read_c(&entity.data[0].entity_type, sizeof(entity.data[0].entity_type))
    if mask & (<uint64_t>1 << 9) != 0:
        reader.read_c(&entity.data[0].current_mode, sizeof(entity.data[0].current_mode))
    if mask & (<uint64_t>1 << 10) != 0:
        reader.read_c(&entity.data[0].mode_start_time, sizeof(entity.data[0].mode_start_time))
    if mask & (<uint64_t>1 << 11) != 0:
        reader.read_c(&entity.data[0].hit_counter, sizeof(entity.data[0].hit_counter))
    if mask & (<uint64_t>1 << 12) != 0:
        reader.read_c(&entity.data[0].last_hit_time, sizeof(entity.data[0].last_hit_time))
    if mask & (<uint64_t>1 << 13) != 0:
        reader.read_c(&entity.data[0].appearance, sizeof(entity.data[0].appearance))
    if mask & (<uint64_t>1 << 14) != 0:
        reader.read_c(&entity.data[0].flags, sizeof(entity.data[0].flags))
    if mask & (<uint64_t>1 << 15) != 0:
        reader.read_c(&entity.data[0].roll_time, sizeof(entity.data[0].roll_time))
    if mask & (<uint64_t>1 << 16) != 0:
        reader.read_c(&entity.data[0].stun_time, sizeof(entity.data[0].stun_time))
    if mask & (<uint64_t>1 << 17) != 0:
        reader.read_c(&entity.data[0].slowed_time, sizeof(entity.data[0].slowed_time))
    if mask & (<uint64_t>1 << 18) != 0:
        reader.read_c(&entity.data[0].make_blue_time, sizeof(entity.data[0].make_blue_time))
    if mask & (<uint64_t>1 << 19) != 0:
        reader.read_c(&entity.data[0].speed_up_time, sizeof(entity.data[0].speed_up_time))
    if mask & (<uint64_t>1 << 20) != 0:
        reader.read_c(&entity.data[0].show_patch_time, sizeof(entity.data[0].show_patch_time))
    if mask & (<uint64_t>1 << 21) != 0:
        reader.read_c(&entity.data[0].class_type, sizeof(entity.data[0].class_type))
    if mask & (<uint64_t>1 << 22) != 0:
        reader.read_c(&entity.data[0].specialization, sizeof(entity.data[0].specialization))
    if mask & (<uint64_t>1 << 23) != 0:
        reader.read_c(&entity.data[0].charged_mp, sizeof(entity.data[0].charged_mp))
    if mask & (<uint64_t>1 << 24) != 0:
        reader.read_c(&entity.data[0].not_used_1, sizeof(entity.data[0].not_used_1))
        reader.read_c(&entity.data[0].not_used_2, sizeof(entity.data[0].not_used_2))
        reader.read_c(&entity.data[0].not_used_3, sizeof(entity.data[0].not_used_3))
    if mask & (<uint64_t>1 << 25) != 0:
        reader.read_c(&entity.data[0].not_used_4, sizeof(entity.data[0].not_used_4))
        reader.read_c(&entity.data[0].not_used_5, sizeof(entity.data[0].not_used_5))
        reader.read_c(&entity.data[0].not_used_6, sizeof(entity.data[0].not_used_6))
    if mask & (<uint64_t>1 << 26) != 0:
        reader.read_c(&entity.data[0].ray_hit, sizeof(entity.data[0].ray_hit))
    if mask & (<uint64_t>1 << 27) != 0:
        reader.read_c(&entity.data[0].hp, sizeof(entity.data[0].hp))
    if mask & (<uint64_t>1 << 28) != 0:
        reader.read_c(&entity.data[0].mp, sizeof(entity.data[0].mp))
    if mask & (<uint64_t>1 << 29) != 0:
        reader.read_c(&entity.data[0].block_power, sizeof(entity.data[0].block_power))
    if mask & (<uint64_t>1 << 30) != 0:
        reader.read_c(&entity.data[0].max_hp_multiplier, sizeof(entity.data[0].max_hp_multiplier))
        reader.read_c(&entity.data[0].shoot_speed, sizeof(entity.data[0].shoot_speed))
        reader.read_c(&entity.data[0].damage_multiplier, sizeof(entity.data[0].damage_multiplier))
        reader.read_c(&entity.data[0].armor_multiplier, sizeof(entity.data[0].armor_multiplier))
        reader.read_c(&entity.data[0].resi_multiplier, sizeof(entity.data[0].resi_multiplier))
    if mask & (<uint64_t>1 << 31) != 0:
        reader.read_c(&entity.data[0].not_used7, sizeof(entity.data[0].not_used7))
    if mask & (<uint64_t>1 << 32) != 0:
        reader.read_c(&entity.data[0].not_used8, sizeof(entity.data[0].not_used8))
    if mask & (<uint64_t>1 << 33) != 0:
        reader.read_c(&entity.data[0].level, sizeof(entity.data[0].level))
    if mask & (<uint64_t>1 << 34) != 0:
        reader.read_c(&entity.data[0].current_xp, sizeof(entity.data[0].current_xp))
    if mask & (<uint64_t>1 << 35) != 0:
        reader.read_c(&entity.data[0].parent_owner, sizeof(entity.data[0].parent_owner))
    if mask & (<uint64_t>1 << 36) != 0:
        reader.read_c(&entity.data[0].unknown_or_not_used1, sizeof(entity.data[0].unknown_or_not_used1))
        reader.read_c(&entity.data[0].unknown_or_not_used2, sizeof(entity.data[0].unknown_or_not_used2))
    if mask & (<uint64_t>1 << 37) != 0:
        reader.read_c(&entity.data[0].power_base, sizeof(entity.data[0].power_base))
    if mask & (<uint64_t>1 << 38) != 0:
        reader.read_c(&entity.data[0].unknown_or_not_used4, sizeof(entity.data[0].unknown_or_not_used4))
    if mask & (<uint64_t>1 << 39) != 0:
        reader.read_c(&entity.data[0].start_chunk, sizeof(entity.data[0].start_chunk))
    if mask & (<uint64_t>1 << 40) != 0:
        reader.read_c(&entity.data[0].spawn_pos, sizeof(entity.data[0].spawn_pos))
    if mask & (<uint64_t>1 << 41) != 0:
        reader.read_c(&entity.data[0].not_used20, sizeof(entity.data[0].not_used20))
    if mask & (<uint64_t>1 << 42) != 0:
        reader.read_c(&entity.data[0].not_used19, sizeof(entity.data[0].not_used19))
    if mask & (<uint64_t>1 << 43) != 0:
        reader.read_c(&entity.data[0].consumable, sizeof(entity.data[0].consumable))
    if mask & (<uint64_t>1 << 44) != 0:
        reader.read_c(&entity.data[0].equipment, sizeof(entity.data[0].equipment))
    if mask & (<uint64_t>1 << 45) != 0:
        reader.read_c(&entity.data[0].name, sizeof(entity.data[0].name))
    if mask & (<uint64_t>1 << 46) != 0:
        reader.read_c(&entity.data[0].skills, sizeof(entity.data[0].skills))
    if mask & (<uint64_t>1 << 47) != 0:
        reader.read_c(&entity.data[0].mana_cubes, sizeof(entity.data[0].mana_cubes))

    return mask


cpdef unsigned int get_masked_size(uint64_t mask):
    cdef unsigned int size = 0
    if mask & (<uint64_t>1 << 0) != 0:
        size += 24
    if mask & (<uint64_t>1 << 1) != 0:
        size += 12
    if mask & (<uint64_t>1 << 2) != 0:
        size += 12
    if mask & (<uint64_t>1 << 3) != 0:
        size += 12
    if mask & (<uint64_t>1 << 4) != 0:
        size += 12
    if mask & (<uint64_t>1 << 5) != 0:
        size += 4
    if mask & (<uint64_t>1 << 6) != 0:
        size += 4
    if mask & (<uint64_t>1 << 7) != 0:
        size += 1
    if mask & (<uint64_t>1 << 8) != 0:
        size += 4
    if mask & (<uint64_t>1 << 9) != 0:
        size += 1
    if mask & (<uint64_t>1 << 10) != 0:
        size += 4
    if mask & (<uint64_t>1 << 11) != 0:
        size += 4
    if mask & (<uint64_t>1 << 12) != 0:
        size += 4
    if mask & (<uint64_t>1 << 13) != 0:
        size += 172
    if mask & (<uint64_t>1 << 14) != 0:
        size += 2
    if mask & (<uint64_t>1 << 15) != 0:
        size += 4
    if mask & (<uint64_t>1 << 16) != 0:
        size += 4
    if mask & (<uint64_t>1 << 17) != 0:
        size += 4
    if mask & (<uint64_t>1 << 18) != 0:
        size += 4
    if mask & (<uint64_t>1 << 19) != 0:
        size += 4
    if mask & (<uint64_t>1 << 20) != 0:
        size += 4
    if mask & (<uint64_t>1 << 21) != 0:
        size += 1
    if mask & (<uint64_t>1 << 22) != 0:
        size += 1
    if mask & (<uint64_t>1 << 23) != 0:
        size += 4
    if mask & (<uint64_t>1 << 24) != 0:
        size += 12
    if mask & (<uint64_t>1 << 25) != 0:
        size += 12
    if mask & (<uint64_t>1 << 26) != 0:
        size += 12
    if mask & (<uint64_t>1 << 27) != 0:
        size += 4
    if mask & (<uint64_t>1 << 28) != 0:
        size += 4
    if mask & (<uint64_t>1 << 29) != 0:
        size += 4
    if mask & (<uint64_t>1 << 30) != 0:
        size += 20
    if mask & (<uint64_t>1 << 31) != 0:
        size += 1
    if mask & (<uint64_t>1 << 32) != 0:
        size += 1
    if mask & (<uint64_t>1 << 33) != 0:
        size += 4
    if mask & (<uint64_t>1 << 34) != 0:
        size += 4
    if mask & (<uint64_t>1 << 35) != 0:
        size += 8
    if mask & (<uint64_t>1 << 36) != 0:
        size += 8
    if mask & (<uint64_t>1 << 37) != 0:
        size += 1
    if mask & (<uint64_t>1 << 38) != 0:
        size += 4
    if mask & (<uint64_t>1 << 39) != 0:
        size += 12
    if mask & (<uint64_t>1 << 40) != 0:
        size += 24
    if mask & (<uint64_t>1 << 41) != 0:
        size += 12
    if mask & (<uint64_t>1 << 42) != 0:
        size += 1
    if mask & (<uint64_t>1 << 43) != 0:
        size += 280
    if mask & (<uint64_t>1 << 44) != 0:
        size += 3640
    if mask & (<uint64_t>1 << 45) != 0:
        size += 16
    if mask & (<uint64_t>1 << 46) != 0:
        size += 44
    if mask & (<uint64_t>1 << 47) != 0:
        size += 4
    return size


cpdef write_masked_data(WrapEntityData entity, ByteWriter writer, uint64_t mask):
    writer.write_uint64(mask)
    cdef bytes view
    if mask & (<uint64_t>1 << 0) != 0:
        writer.write_c(&entity.data[0].pos, sizeof(entity.data[0].pos))
    if mask & (<uint64_t>1 << 1) != 0:
        writer.write_c(&entity.data[0].body_roll, sizeof(entity.data[0].body_roll))
        writer.write_c(&entity.data[0].body_pitch, sizeof(entity.data[0].body_pitch))
        writer.write_c(&entity.data[0].body_yaw, sizeof(entity.data[0].body_yaw))
    if mask & (<uint64_t>1 << 2) != 0:
        writer.write_c(&entity.data[0].velocity, sizeof(entity.data[0].velocity))
    if mask & (<uint64_t>1 << 3) != 0:
        writer.write_c(&entity.data[0].accel, sizeof(entity.data[0].accel))
    if mask & (<uint64_t>1 << 4) != 0:
        writer.write_c(&entity.data[0].extra_vel, sizeof(entity.data[0].extra_vel))
    if mask & (<uint64_t>1 << 5) != 0:
        writer.write_c(&entity.data[0].look_pitch, sizeof(entity.data[0].look_pitch))
    if mask & (<uint64_t>1 << 6) != 0:
        writer.write_c(&entity.data[0].physics_flags, sizeof(entity.data[0].physics_flags))
    if mask & (<uint64_t>1 << 7) != 0:
        writer.write_c(&entity.data[0].hostile_type, sizeof(entity.data[0].hostile_type))
    if mask & (<uint64_t>1 << 8) != 0:
        writer.write_c(&entity.data[0].entity_type, sizeof(entity.data[0].entity_type))
    if mask & (<uint64_t>1 << 9) != 0:
        writer.write_c(&entity.data[0].current_mode, sizeof(entity.data[0].current_mode))
    if mask & (<uint64_t>1 << 10) != 0:
        writer.write_c(&entity.data[0].mode_start_time, sizeof(entity.data[0].mode_start_time))
    if mask & (<uint64_t>1 << 11) != 0:
        writer.write_c(&entity.data[0].hit_counter, sizeof(entity.data[0].hit_counter))
    if mask & (<uint64_t>1 << 12) != 0:
        writer.write_c(&entity.data[0].last_hit_time, sizeof(entity.data[0].last_hit_time))
    if mask & (<uint64_t>1 << 13) != 0:
        writer.write_c(&entity.data[0].appearance, sizeof(entity.data[0].appearance))
    if mask & (<uint64_t>1 << 14) != 0:
        writer.write_c(&entity.data[0].flags, sizeof(entity.data[0].flags))
    if mask & (<uint64_t>1 << 15) != 0:
        writer.write_c(&entity.data[0].roll_time, sizeof(entity.data[0].roll_time))
    if mask & (<uint64_t>1 << 16) != 0:
        writer.write_c(&entity.data[0].stun_time, sizeof(entity.data[0].stun_time))
    if mask & (<uint64_t>1 << 17) != 0:
        writer.write_c(&entity.data[0].slowed_time, sizeof(entity.data[0].slowed_time))
    if mask & (<uint64_t>1 << 18) != 0:
        writer.write_c(&entity.data[0].make_blue_time, sizeof(entity.data[0].make_blue_time))
    if mask & (<uint64_t>1 << 19) != 0:
        writer.write_c(&entity.data[0].speed_up_time, sizeof(entity.data[0].speed_up_time))
    if mask & (<uint64_t>1 << 20) != 0:
        writer.write_c(&entity.data[0].show_patch_time, sizeof(entity.data[0].show_patch_time))
    if mask & (<uint64_t>1 << 21) != 0:
        writer.write_c(&entity.data[0].class_type, sizeof(entity.data[0].class_type))
    if mask & (<uint64_t>1 << 22) != 0:
        writer.write_c(&entity.data[0].specialization, sizeof(entity.data[0].specialization))
    if mask & (<uint64_t>1 << 23) != 0:
        writer.write_c(&entity.data[0].charged_mp, sizeof(entity.data[0].charged_mp))
    if mask & (<uint64_t>1 << 24) != 0:
        writer.write_c(&entity.data[0].not_used_1, sizeof(entity.data[0].not_used_1))
        writer.write_c(&entity.data[0].not_used_2, sizeof(entity.data[0].not_used_2))
        writer.write_c(&entity.data[0].not_used_3, sizeof(entity.data[0].not_used_3))
    if mask & (<uint64_t>1 << 25) != 0:
        writer.write_c(&entity.data[0].not_used_4, sizeof(entity.data[0].not_used_4))
        writer.write_c(&entity.data[0].not_used_5, sizeof(entity.data[0].not_used_5))
        writer.write_c(&entity.data[0].not_used_6, sizeof(entity.data[0].not_used_6))
    if mask & (<uint64_t>1 << 26) != 0:
        writer.write_c(&entity.data[0].ray_hit, sizeof(entity.data[0].ray_hit))
    if mask & (<uint64_t>1 << 27) != 0:
        writer.write_c(&entity.data[0].hp, sizeof(entity.data[0].hp))
    if mask & (<uint64_t>1 << 28) != 0:
        writer.write_c(&entity.data[0].mp, sizeof(entity.data[0].mp))
    if mask & (<uint64_t>1 << 29) != 0:
        writer.write_c(&entity.data[0].block_power, sizeof(entity.data[0].block_power))
    if mask & (<uint64_t>1 << 30) != 0:
        writer.write_c(&entity.data[0].max_hp_multiplier, sizeof(entity.data[0].max_hp_multiplier))
        writer.write_c(&entity.data[0].shoot_speed, sizeof(entity.data[0].shoot_speed))
        writer.write_c(&entity.data[0].damage_multiplier, sizeof(entity.data[0].damage_multiplier))
        writer.write_c(&entity.data[0].armor_multiplier, sizeof(entity.data[0].armor_multiplier))
        writer.write_c(&entity.data[0].resi_multiplier, sizeof(entity.data[0].resi_multiplier))
    if mask & (<uint64_t>1 << 31) != 0:
        writer.write_c(&entity.data[0].not_used7, sizeof(entity.data[0].not_used7))
    if mask & (<uint64_t>1 << 32) != 0:
        writer.write_c(&entity.data[0].not_used8, sizeof(entity.data[0].not_used8))
    if mask & (<uint64_t>1 << 33) != 0:
        writer.write_c(&entity.data[0].level, sizeof(entity.data[0].level))
    if mask & (<uint64_t>1 << 34) != 0:
        writer.write_c(&entity.data[0].current_xp, sizeof(entity.data[0].current_xp))
    if mask & (<uint64_t>1 << 35) != 0:
        writer.write_c(&entity.data[0].parent_owner, sizeof(entity.data[0].parent_owner))
    if mask & (<uint64_t>1 << 36) != 0:
        writer.write_c(&entity.data[0].unknown_or_not_used1, sizeof(entity.data[0].unknown_or_not_used1))
        writer.write_c(&entity.data[0].unknown_or_not_used2, sizeof(entity.data[0].unknown_or_not_used2))
    if mask & (<uint64_t>1 << 37) != 0:
        writer.write_c(&entity.data[0].power_base, sizeof(entity.data[0].power_base))
    if mask & (<uint64_t>1 << 38) != 0:
        writer.write_c(&entity.data[0].unknown_or_not_used4, sizeof(entity.data[0].unknown_or_not_used4))
    if mask & (<uint64_t>1 << 39) != 0:
        writer.write_c(&entity.data[0].start_chunk, sizeof(entity.data[0].start_chunk))
    if mask & (<uint64_t>1 << 40) != 0:
        writer.write_c(&entity.data[0].spawn_pos, sizeof(entity.data[0].spawn_pos))
    if mask & (<uint64_t>1 << 41) != 0:
        writer.write_c(&entity.data[0].not_used20, sizeof(entity.data[0].not_used20))
    if mask & (<uint64_t>1 << 42) != 0:
        writer.write_c(&entity.data[0].not_used19, sizeof(entity.data[0].not_used19))
    if mask & (<uint64_t>1 << 43) != 0:
        writer.write_c(&entity.data[0].consumable, sizeof(entity.data[0].consumable))
    if mask & (<uint64_t>1 << 44) != 0:
        writer.write_c(&entity.data[0].equipment, sizeof(entity.data[0].equipment))
    if mask & (<uint64_t>1 << 45) != 0:
        writer.write_c(&entity.data[0].name, sizeof(entity.data[0].name))
    if mask & (<uint64_t>1 << 46) != 0:
        writer.write_c(&entity.data[0].skills, sizeof(entity.data[0].skills))
    if mask & (<uint64_t>1 << 47) != 0:
        writer.write_c(&entity.data[0].mana_cubes, sizeof(entity.data[0].mana_cubes))
def get_mask_desc(uint64_t mask):
    cdef dict ret = {}
    if mask & (<uint64_t>1 << 0) != 0:
        ret[0] = "pos"
    if mask & (<uint64_t>1 << 1) != 0:
        ret[1] = "orient"
    if mask & (<uint64_t>1 << 2) != 0:
        ret[2] = "vel"
    if mask & (<uint64_t>1 << 3) != 0:
        ret[3] = "accel"
    if mask & (<uint64_t>1 << 4) != 0:
        ret[4] = "extra_vel"
    if mask & (<uint64_t>1 << 5) != 0:
        ret[5] = "look_pitch"
    if mask & (<uint64_t>1 << 6) != 0:
        ret[6] = "physics"
    if mask & (<uint64_t>1 << 7) != 0:
        ret[7] = "hostile"
    if mask & (<uint64_t>1 << 8) != 0:
        ret[8] = "type"
    if mask & (<uint64_t>1 << 9) != 0:
        ret[9] = "mode"
    if mask & (<uint64_t>1 << 10) != 0:
        ret[10] = "mode_time"
    if mask & (<uint64_t>1 << 11) != 0:
        ret[11] = "hit_counter"
    if mask & (<uint64_t>1 << 12) != 0:
        ret[12] = "last_hit"
    if mask & (<uint64_t>1 << 13) != 0:
        ret[13] = "appearance"
    if mask & (<uint64_t>1 << 14) != 0:
        ret[14] = "flags"
    if mask & (<uint64_t>1 << 15) != 0:
        ret[15] = "roll"
    if mask & (<uint64_t>1 << 16) != 0:
        ret[16] = "stun"
    if mask & (<uint64_t>1 << 17) != 0:
        ret[17] = "slowed"
    if mask & (<uint64_t>1 << 18) != 0:
        ret[18] = "make_blue"
    if mask & (<uint64_t>1 << 19) != 0:
        ret[19] = "speed_up"
    if mask & (<uint64_t>1 << 20) != 0:
        ret[20] = "show_patch"
    if mask & (<uint64_t>1 << 21) != 0:
        ret[21] = "class"
    if mask & (<uint64_t>1 << 22) != 0:
        ret[22] = "specialization"
    if mask & (<uint64_t>1 << 23) != 0:
        ret[23] = "charged_mp"
    if mask & (<uint64_t>1 << 26) != 0:
        ret[26] = "ray"
    if mask & (<uint64_t>1 << 27) != 0:
        ret[27] = "hp"
    if mask & (<uint64_t>1 << 28) != 0:
        ret[28] = "mp"
    if mask & (<uint64_t>1 << 29) != 0:
        ret[29] = "block_power"
    if mask & (<uint64_t>1 << 30) != 0:
        ret[30] = "multiplier"
    if mask & (<uint64_t>1 << 33) != 0:
        ret[33] = "level"
    if mask & (<uint64_t>1 << 34) != 0:
        ret[34] = "xp"
    if mask & (<uint64_t>1 << 35) != 0:
        ret[35] = "owner"
    if mask & (<uint64_t>1 << 37) != 0:
        ret[37] = "power_base"
    if mask & (<uint64_t>1 << 39) != 0:
        ret[39] = "start_chunk"
    if mask & (<uint64_t>1 << 40) != 0:
        ret[40] = "spawn"
    if mask & (<uint64_t>1 << 43) != 0:
        ret[43] = "consumable"
    if mask & (<uint64_t>1 << 44) != 0:
        ret[44] = "equipment"
    if mask & (<uint64_t>1 << 45) != 0:
        ret[45] = "name"
    if mask & (<uint64_t>1 << 46) != 0:
        ret[46] = "skill"
    if mask & (<uint64_t>1 << 47) != 0:
        ret[47] = "mana_cubes"
    return ret
cpdef uint64_t get_mask(WrapEntityData old_ent, WrapEntityData new_ent):
    cdef uint64_t mask = 0
    mask |= <uint64_t>(memcmp(&old_ent.data[0].pos, &new_ent.data[0].pos, sizeof(old_ent.data[0].pos)) != 0) << 0
    mask |= <uint64_t>(memcmp(&old_ent.data[0].body_roll, &new_ent.data[0].body_roll, sizeof(old_ent.data[0].body_roll)) != 0) << 1
    mask |= <uint64_t>(memcmp(&old_ent.data[0].body_pitch, &new_ent.data[0].body_pitch, sizeof(old_ent.data[0].body_pitch)) != 0) << 1
    mask |= <uint64_t>(memcmp(&old_ent.data[0].body_yaw, &new_ent.data[0].body_yaw, sizeof(old_ent.data[0].body_yaw)) != 0) << 1
    mask |= <uint64_t>(memcmp(&old_ent.data[0].velocity, &new_ent.data[0].velocity, sizeof(old_ent.data[0].velocity)) != 0) << 2
    mask |= <uint64_t>(memcmp(&old_ent.data[0].accel, &new_ent.data[0].accel, sizeof(old_ent.data[0].accel)) != 0) << 3
    mask |= <uint64_t>(memcmp(&old_ent.data[0].extra_vel, &new_ent.data[0].extra_vel, sizeof(old_ent.data[0].extra_vel)) != 0) << 4
    mask |= <uint64_t>(memcmp(&old_ent.data[0].look_pitch, &new_ent.data[0].look_pitch, sizeof(old_ent.data[0].look_pitch)) != 0) << 5
    mask |= <uint64_t>(memcmp(&old_ent.data[0].physics_flags, &new_ent.data[0].physics_flags, sizeof(old_ent.data[0].physics_flags)) != 0) << 6
    mask |= <uint64_t>(memcmp(&old_ent.data[0].hostile_type, &new_ent.data[0].hostile_type, sizeof(old_ent.data[0].hostile_type)) != 0) << 7
    mask |= <uint64_t>(memcmp(&old_ent.data[0].entity_type, &new_ent.data[0].entity_type, sizeof(old_ent.data[0].entity_type)) != 0) << 8
    mask |= <uint64_t>(memcmp(&old_ent.data[0].current_mode, &new_ent.data[0].current_mode, sizeof(old_ent.data[0].current_mode)) != 0) << 9
    mask |= <uint64_t>(memcmp(&old_ent.data[0].mode_start_time, &new_ent.data[0].mode_start_time, sizeof(old_ent.data[0].mode_start_time)) != 0) << 10
    mask |= <uint64_t>(memcmp(&old_ent.data[0].hit_counter, &new_ent.data[0].hit_counter, sizeof(old_ent.data[0].hit_counter)) != 0) << 11
    mask |= <uint64_t>(memcmp(&old_ent.data[0].last_hit_time, &new_ent.data[0].last_hit_time, sizeof(old_ent.data[0].last_hit_time)) != 0) << 12
    mask |= <uint64_t>(memcmp(&old_ent.data[0].appearance, &new_ent.data[0].appearance, sizeof(old_ent.data[0].appearance)) != 0) << 13
    mask |= <uint64_t>(memcmp(&old_ent.data[0].flags, &new_ent.data[0].flags, sizeof(old_ent.data[0].flags)) != 0) << 14
    mask |= <uint64_t>(memcmp(&old_ent.data[0].roll_time, &new_ent.data[0].roll_time, sizeof(old_ent.data[0].roll_time)) != 0) << 15
    mask |= <uint64_t>(memcmp(&old_ent.data[0].stun_time, &new_ent.data[0].stun_time, sizeof(old_ent.data[0].stun_time)) != 0) << 16
    mask |= <uint64_t>(memcmp(&old_ent.data[0].slowed_time, &new_ent.data[0].slowed_time, sizeof(old_ent.data[0].slowed_time)) != 0) << 17
    mask |= <uint64_t>(memcmp(&old_ent.data[0].make_blue_time, &new_ent.data[0].make_blue_time, sizeof(old_ent.data[0].make_blue_time)) != 0) << 18
    mask |= <uint64_t>(memcmp(&old_ent.data[0].speed_up_time, &new_ent.data[0].speed_up_time, sizeof(old_ent.data[0].speed_up_time)) != 0) << 19
    mask |= <uint64_t>(memcmp(&old_ent.data[0].show_patch_time, &new_ent.data[0].show_patch_time, sizeof(old_ent.data[0].show_patch_time)) != 0) << 20
    mask |= <uint64_t>(memcmp(&old_ent.data[0].class_type, &new_ent.data[0].class_type, sizeof(old_ent.data[0].class_type)) != 0) << 21
    mask |= <uint64_t>(memcmp(&old_ent.data[0].specialization, &new_ent.data[0].specialization, sizeof(old_ent.data[0].specialization)) != 0) << 22
    mask |= <uint64_t>(memcmp(&old_ent.data[0].charged_mp, &new_ent.data[0].charged_mp, sizeof(old_ent.data[0].charged_mp)) != 0) << 23
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_1, &new_ent.data[0].not_used_1, sizeof(old_ent.data[0].not_used_1)) != 0) << 24
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_2, &new_ent.data[0].not_used_2, sizeof(old_ent.data[0].not_used_2)) != 0) << 24
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_3, &new_ent.data[0].not_used_3, sizeof(old_ent.data[0].not_used_3)) != 0) << 24
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_4, &new_ent.data[0].not_used_4, sizeof(old_ent.data[0].not_used_4)) != 0) << 25
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_5, &new_ent.data[0].not_used_5, sizeof(old_ent.data[0].not_used_5)) != 0) << 25
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used_6, &new_ent.data[0].not_used_6, sizeof(old_ent.data[0].not_used_6)) != 0) << 25
    mask |= <uint64_t>(memcmp(&old_ent.data[0].ray_hit, &new_ent.data[0].ray_hit, sizeof(old_ent.data[0].ray_hit)) != 0) << 26
    mask |= <uint64_t>(memcmp(&old_ent.data[0].hp, &new_ent.data[0].hp, sizeof(old_ent.data[0].hp)) != 0) << 27
    mask |= <uint64_t>(memcmp(&old_ent.data[0].mp, &new_ent.data[0].mp, sizeof(old_ent.data[0].mp)) != 0) << 28
    mask |= <uint64_t>(memcmp(&old_ent.data[0].block_power, &new_ent.data[0].block_power, sizeof(old_ent.data[0].block_power)) != 0) << 29
    mask |= <uint64_t>(memcmp(&old_ent.data[0].max_hp_multiplier, &new_ent.data[0].max_hp_multiplier, sizeof(old_ent.data[0].max_hp_multiplier)) != 0) << 30
    mask |= <uint64_t>(memcmp(&old_ent.data[0].shoot_speed, &new_ent.data[0].shoot_speed, sizeof(old_ent.data[0].shoot_speed)) != 0) << 30
    mask |= <uint64_t>(memcmp(&old_ent.data[0].damage_multiplier, &new_ent.data[0].damage_multiplier, sizeof(old_ent.data[0].damage_multiplier)) != 0) << 30
    mask |= <uint64_t>(memcmp(&old_ent.data[0].armor_multiplier, &new_ent.data[0].armor_multiplier, sizeof(old_ent.data[0].armor_multiplier)) != 0) << 30
    mask |= <uint64_t>(memcmp(&old_ent.data[0].resi_multiplier, &new_ent.data[0].resi_multiplier, sizeof(old_ent.data[0].resi_multiplier)) != 0) << 30
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used7, &new_ent.data[0].not_used7, sizeof(old_ent.data[0].not_used7)) != 0) << 31
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used8, &new_ent.data[0].not_used8, sizeof(old_ent.data[0].not_used8)) != 0) << 32
    mask |= <uint64_t>(memcmp(&old_ent.data[0].level, &new_ent.data[0].level, sizeof(old_ent.data[0].level)) != 0) << 33
    mask |= <uint64_t>(memcmp(&old_ent.data[0].current_xp, &new_ent.data[0].current_xp, sizeof(old_ent.data[0].current_xp)) != 0) << 34
    mask |= <uint64_t>(memcmp(&old_ent.data[0].parent_owner, &new_ent.data[0].parent_owner, sizeof(old_ent.data[0].parent_owner)) != 0) << 35
    mask |= <uint64_t>(memcmp(&old_ent.data[0].unknown_or_not_used1, &new_ent.data[0].unknown_or_not_used1, sizeof(old_ent.data[0].unknown_or_not_used1)) != 0) << 36
    mask |= <uint64_t>(memcmp(&old_ent.data[0].unknown_or_not_used2, &new_ent.data[0].unknown_or_not_used2, sizeof(old_ent.data[0].unknown_or_not_used2)) != 0) << 36
    mask |= <uint64_t>(memcmp(&old_ent.data[0].power_base, &new_ent.data[0].power_base, sizeof(old_ent.data[0].power_base)) != 0) << 37
    mask |= <uint64_t>(memcmp(&old_ent.data[0].unknown_or_not_used4, &new_ent.data[0].unknown_or_not_used4, sizeof(old_ent.data[0].unknown_or_not_used4)) != 0) << 38
    mask |= <uint64_t>(memcmp(&old_ent.data[0].start_chunk, &new_ent.data[0].start_chunk, sizeof(old_ent.data[0].start_chunk)) != 0) << 39
    mask |= <uint64_t>(memcmp(&old_ent.data[0].spawn_pos, &new_ent.data[0].spawn_pos, sizeof(old_ent.data[0].spawn_pos)) != 0) << 40
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used20, &new_ent.data[0].not_used20, sizeof(old_ent.data[0].not_used20)) != 0) << 41
    mask |= <uint64_t>(memcmp(&old_ent.data[0].not_used19, &new_ent.data[0].not_used19, sizeof(old_ent.data[0].not_used19)) != 0) << 42
    mask |= <uint64_t>(memcmp(&old_ent.data[0].consumable, &new_ent.data[0].consumable, sizeof(old_ent.data[0].consumable)) != 0) << 43
    mask |= <uint64_t>(memcmp(&old_ent.data[0].equipment, &new_ent.data[0].equipment, sizeof(old_ent.data[0].equipment)) != 0) << 44
    mask |= <uint64_t>(memcmp(&old_ent.data[0].name, &new_ent.data[0].name, sizeof(old_ent.data[0].name)) != 0) << 45
    mask |= <uint64_t>(memcmp(&old_ent.data[0].skills, &new_ent.data[0].skills, sizeof(old_ent.data[0].skills)) != 0) << 46
    mask |= <uint64_t>(memcmp(&old_ent.data[0].mana_cubes, &new_ent.data[0].mana_cubes, sizeof(old_ent.data[0].mana_cubes)) != 0) << 47
    return mask
