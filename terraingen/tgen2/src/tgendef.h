// Definitions (autogenerated)

#include <stdint.h>

typedef float vec3[3];
typedef int64_t qvec3[3];
typedef int32_t ivec3[3];

struct ItemUpgrade // size 8
{
    int8_t x;
    int8_t y;
    int8_t z;
    int8_t material;
    int32_t level;
};
static_assert(sizeof(ItemUpgrade) == 8,
              "Invalid size for ItemUpgrade");
struct ItemData // size 280
{
    uint8_t type;
    uint8_t sub_type;
    uint8_t pad2[2];
    uint32_t modifier;
    uint32_t minus_modifier;
    uint8_t rarity;
    uint8_t material;
    uint8_t flags;
    uint8_t pad8[1];
    int16_t level;
    uint8_t pad10[2];
    ItemUpgrade items[32];
    uint32_t upgrade_count;
};
static_assert(sizeof(ItemData) == 280,
              "Invalid size for ItemData");
struct AppearanceData // size 172
{
    uint8_t not_used_1;
    uint8_t not_used_2;
    uint8_t hair_red;
    uint8_t hair_green;
    uint8_t hair_blue;
    uint8_t pad5[1];
    uint16_t flags;
    vec3 scale;
    int16_t head_model;
    int16_t hair_model;
    int16_t hand_model;
    int16_t foot_model;
    int16_t body_model;
    int16_t tail_model;
    int16_t shoulder2_model;
    int16_t wing_model;
    float head_scale;
    float body_scale;
    float hand_scale;
    float foot_scale;
    float shoulder2_scale;
    float weapon_scale;
    float tail_scale;
    float shoulder_scale;
    float wing_scale;
    float body_pitch;
    float arm_pitch;
    float arm_roll;
    float arm_yaw;
    float feet_pitch;
    float wing_pitch;
    float back_pitch;
    vec3 body_offset;
    vec3 head_offset;
    vec3 hand_offset;
    vec3 foot_offset;
    vec3 tail_offset;
    vec3 wing_offset;
};
static_assert(sizeof(AppearanceData) == 172,
              "Invalid size for AppearanceData");
struct EntityData // size 4456
{
    qvec3 pos;
    float body_roll;
    float body_pitch;
    float body_yaw;
    vec3 velocity;
    vec3 accel;
    vec3 extra_vel;
    float look_pitch;
    uint32_t physics_flags;
    uint8_t hostile_type;
    int8_t pad10[3];
    uint32_t entity_type;
    uint8_t current_mode;
    int8_t pad13[3];
    uint32_t mode_start_time;
    uint32_t hit_counter;
    uint32_t last_hit_time;
    AppearanceData appearance;
    uint16_t flags;
    int8_t pad19[2];
    uint32_t roll_time;
    int32_t stun_time;
    uint32_t slowed_time;
    uint32_t make_blue_time;
    uint32_t speed_up_time;
    float show_patch_time;
    uint8_t class_type;
    uint8_t specialization;
    int8_t pad28[2];
    float charged_mp;
    uint32_t not_used_1;
    uint32_t not_used_2;
    uint32_t not_used_3;
    uint32_t not_used_4;
    uint32_t not_used_5;
    uint32_t not_used_6;
    vec3 ray_hit;
    float hp;
    float mp;
    float block_power;
    float max_hp_multiplier;
    float shoot_speed;
    float damage_multiplier;
    float armor_multiplier;
    float resi_multiplier;
    uint8_t not_used7;
    uint8_t not_used8;
    int8_t pad47[2];
    int32_t level;
    int32_t current_xp;
    uint64_t parent_owner;
    uint32_t unknown_or_not_used1;
    uint32_t unknown_or_not_used2;
    uint8_t power_base;
    int8_t pad54[3];
    int32_t unknown_or_not_used4;
    ivec3 start_chunk;
    uint32_t super_weird;
    qvec3 spawn_pos;
    uint8_t not_used19;
    int8_t pad60[3];
    ivec3 not_used20;
    ItemData consumable;
    ItemData equipment[13];
    uint32_t skills[11];
    uint32_t mana_cubes;
    int8_t name[16];
};
static_assert(sizeof(EntityData) == 4456,
              "Invalid size for EntityData");
struct ItemWithHeader // size 284
{
    uint32_t header;
    ItemData data;
};
static_assert(sizeof(ItemWithHeader) == 284,
              "Invalid size for ItemWithHeader");
struct ItemWithHeaderList // size 12
{
    uint32_t vec_start;
    uint32_t vec_end;
    uint32_t vec_capacity;
};
static_assert(sizeof(ItemWithHeaderList) == 12,
              "Invalid size for ItemWithHeaderList");
struct ItemWithHeaderLists // size 12
{
    uint32_t vec_start;
    uint32_t vec_end;
    uint32_t vec_capacity;
};
static_assert(sizeof(ItemWithHeaderLists) == 12,
              "Invalid size for ItemWithHeaderLists");
struct StaticEntityHeader // size 72
{
    uint32_t entity_type;
    int8_t pad1[4];
    qvec3 pos;
    uint32_t orientation;
    vec3 size;
    uint8_t closed;
    int8_t pad6[3];
    uint32_t time_offset;
    uint32_t something8;
    int8_t pad9[4];
    uint64_t user_id;
};
static_assert(sizeof(StaticEntityHeader) == 72,
              "Invalid size for StaticEntityHeader");
struct StaticEntity // size 392
{
    StaticEntityHeader header;
    ItemWithHeaderLists item_with_header_lists;
    uint32_t something1;
    ItemData item;
    uint32_t something2;
    uint32_t something3;
    uint32_t something4;
    uint32_t something5;
    uint32_t something6;
    uint32_t something7;
};
static_assert(sizeof(StaticEntity) == 392,
              "Invalid size for StaticEntity");
struct ItemWithExtra // size 304
{
    ItemWithHeaderLists lists;
    uint32_t something1;
    ItemData item;
    uint32_t something_added1;
    uint32_t something_added2;
};
static_assert(sizeof(ItemWithExtra) == 304,
              "Invalid size for ItemWithExtra");
struct Spawn // size 4336
{
    uint32_t vtable;
    int8_t pad1[4];
    float something1;
    int8_t something2[4];
    int64_t x;
    int64_t y;
    int64_t z;
    int8_t hostile_type;
    int8_t something3[3];
    uint32_t entity_type;
    int8_t class_type;
    int8_t specialization;
    int8_t pad12[2];
    uint32_t level;
    uint32_t something33;
    uint32_t something34;
    uint32_t something35;
    uint32_t something36;
    uint64_t entity_id;
    int8_t enable_flag_8_flags_1;
    int8_t pad20[3];
    float body_yaw;
    int8_t power_base;
    int8_t pad23[3];
    int8_t not_used19;
    int8_t pad25[3];
    uint32_t not_used20;
    uint32_t not_used21;
    uint32_t not_used22;
    uint32_t something14;
    uint32_t something15;
    AppearanceData appearance;
    ItemData items[13];
    float max_hp_multiplier;
    float shoot_speed;
    float damage_multiplier;
    float armor_multiplier;
    float resi_multiplier;
    ItemWithExtra extra_item;
    uint32_t some_12b_p;
    uint32_t some_vec_start;
    uint32_t some_vec_end;
    uint32_t some_vec_capacity;
    uint32_t id_vec_1_start;
    uint32_t id_vec_1_end;
    uint32_t id_vec_1_capacity;
    uint32_t id_vec_2_end_old;
    uint32_t id_vec_2_start;
    uint32_t id_vec_2_end;
    uint32_t id_vec_2_capacity;
    uint32_t unknown_or_not_used4;
    int8_t name[16];
    uint32_t something30;
    uint32_t something31;
    uint32_t something32;
    int8_t something37;
    int8_t pad56[7];
};
static_assert(sizeof(Spawn) == 4336,
              "Invalid size for Spawn");
struct CriticalSection // size 24
{
    uint32_t DebugInfo;
    uint32_t LockCount;
    uint32_t RecursionCount;
    uint32_t OwningThread;
    uint32_t LockSemaphore;
    uint32_t SpinCount;
};
static_assert(sizeof(CriticalSection) == 24,
              "Invalid size for CriticalSection");
struct Color // size 4
{
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
};
static_assert(sizeof(Color) == 4,
              "Invalid size for Color");
struct Field // size 32
{
    uint32_t vtable;
    float f1;
    float f2;
    float f3;
    uint32_t a;
    uint32_t b;
    uint32_t data;
    uint32_t size;
};
static_assert(sizeof(Field) == 32,
              "Invalid size for Field");
struct ChunkItemData // size 328
{
    ItemData item_data;
    qvec3 pos;
    float rotation;
    float scale;
    uint8_t something3;
    int8_t pad5[3];
    uint32_t drop_time;
    uint32_t something5;
    uint32_t something6;
};
static_assert(sizeof(ChunkItemData) == 328,
              "Invalid size for ChunkItemData");
struct Zone // size 200
{
    int32_t vtable;
    int32_t b;
    int32_t c;
    uint32_t static_entities_start;
    uint32_t static_entities_end;
    uint32_t static_entities_capacity;
    uint32_t spawns_start;
    uint32_t spawns_end;
    uint32_t spawns_capacity;
    uint32_t some4_start;
    uint32_t some4_end;
    uint32_t some4_capacity;
    uint32_t items_start;
    uint32_t items_end;
    uint32_t items_capacity;
    uint32_t some9_start;
    uint32_t some9_end;
    uint32_t some9_capacity;
    uint32_t some8_start;
    uint32_t some8_end;
    uint32_t some8_capacity;
    uint32_t some7_start;
    uint32_t some7_end;
    uint32_t some7_capacity;
    uint32_t chunk_x;
    uint32_t chunk_y;
    uint32_t some2_20byte_start;
    uint32_t some2_20byte_end;
    uint32_t some2_20byte_capacity;
    uint8_t word74;
    uint8_t has_chunkitems;
    uint8_t byte76;
    uint8_t pad32;
    uint32_t dword78;
    uint32_t dword7C;
    uint32_t dword80;
    uint8_t byte84;
    uint8_t pad37[3];
    uint32_t some5_start;
    uint32_t some5_end;
    uint32_t some5_capacity;
    uint32_t some6_start;
    uint32_t some6_end;
    uint32_t some6_capacity;
    uint32_t start_something_dynamic_entities;
    uint32_t dwordA4;
    uint32_t fields;
    uint32_t other_chunk_data;
    CriticalSection crit_sec;
};
static_assert(sizeof(Zone) == 200,
              "Invalid size for Zone");
struct SomethingCreature // size 2192
{
    uint32_t dword0;
    uint32_t dword4;
    uint32_t dword8;
    uint32_t dwordC;
    uint32_t dword10;
    uint32_t dword14;
    uint32_t dword18;
    uint32_t dword1C;
    uint32_t dword20;
    uint32_t dword24;
    uint32_t dword28;
    uint32_t dword2C;
    uint32_t dword30;
    uint32_t dword34;
    uint32_t dword38;
    uint32_t dword3C;
    uint32_t dword40;
    uint32_t dword44;
    uint32_t dword48;
    uint32_t dword4C;
    uint32_t dword50;
    uint32_t dword54;
    uint32_t dword58;
    uint32_t dword5C;
    uint32_t dword60;
    uint32_t dword64;
    uint32_t dword68;
    uint32_t dword6C;
    uint32_t dword70;
    uint32_t dword74;
    uint32_t dword78;
    uint32_t dword7C;
    uint32_t dword80;
    uint32_t dword84;
    uint32_t dword88;
    uint32_t dword8C;
    uint32_t dword90;
    uint32_t dword94;
    uint32_t dword98;
    uint32_t dword9C;
    uint32_t dwordA0;
    uint32_t dwordA4;
    uint32_t dwordA8;
    uint32_t dwordAC;
    uint32_t dwordB0;
    uint32_t dwordB4;
    uint32_t dwordB8;
    uint32_t dwordBC;
    uint8_t pad48[4];
    uint32_t dwordC4;
    uint32_t dwordC8;
    uint32_t dwordCC;
    uint32_t dwordD0;
    uint32_t dwordD4;
    uint32_t dwordD8;
    uint32_t dwordDC;
    uint8_t pad56[4];
    uint32_t dwordE4;
    uint32_t dwordE8;
    uint8_t pad59[1920];
    uint32_t dword86C;
    uint32_t dword870;
    uint32_t dword874;
    uint8_t byte878;
    uint8_t pad64[7];
    uint32_t dword880;
    uint32_t dword884;
    uint32_t dword888;
    uint32_t dword88C;
};
static_assert(sizeof(SomethingCreature) == 2192,
              "Invalid size for SomethingCreature");
struct Creature // size 7776
{
    uint32_t vtable;
    uint8_t f4[4];
    uint64_t entity_id;
    EntityData entity_data;
    uint32_t ptr32_1178;
    uint32_t dword117C;
    uint32_t dword1180;
    uint32_t dword1184;
    uint32_t dword1188;
    uint32_t dword118C;
    uint32_t dword1190;
    float float1194;
    float float1198;
    uint32_t dword119C;
    uint8_t f11A0[12];
    uint32_t mapptr24_11AC;
    uint32_t dword11B0;
    uint32_t mapptr24_11B4;
    uint32_t dword11B8;
    uint8_t f11BC[4];
    uint32_t dword11C0;
    uint32_t dword11C4;
    uint32_t dword11C8;
    uint32_t dword11CC;
    uint32_t dword11D0;
    uint32_t dword11D4;
    uint32_t dword11D8;
    ItemWithExtra item_with_extra;
    uint32_t ptr308_130C;
    uint32_t dword1310;
    uint32_t dword1314;
    uint32_t dword1318;
    uint8_t f131C[52];
    uint32_t dword1350;
    uint32_t dword1354;
    uint32_t dword1358;
    uint32_t dword135C;
    uint32_t dword1360;
    uint32_t dword1364;
    uint8_t f1368[12];
    uint32_t dword1374;
    uint32_t dword1378;
    uint32_t dword137C;
    uint8_t f1380[24];
    uint32_t dword1398;
    uint32_t mapptr24_139C;
    uint32_t dword13A0;
    uint32_t creature_map;
    uint32_t dword13A8;
    uint32_t creature_map2;
    uint32_t dword13B0;
    uint32_t dword13B4;
    uint8_t byte13B8;
    uint8_t f13B9[3];
    uint32_t dword13BC;
    uint8_t byte13C0;
    uint8_t f13C1[3];
    uint32_t dword13C4;
    uint32_t dword13C8;
    uint32_t dword13CC;
    uint32_t dword13D0;
    uint32_t dword13D4;
    float dword13D8;
    uint32_t dword13DC;
    uint32_t dword13E0;
    uint32_t behaviour;
    uint32_t dword13E8;
    uint32_t dword13EC;
    uint32_t dword13F0;
    uint32_t dword13F4;
    uint32_t dword13F8;
    uint32_t dword13FC;
    uint32_t dword1400;
    uint32_t dword1404;
    uint32_t dword1408;
    uint32_t mapptr52_140C;
    uint32_t dword1410;
    uint32_t mapptr28_1414;
    uint32_t dword1418;
    uint32_t dword141C;
    uint32_t dword1420;
    uint32_t dword1424;
    uint8_t f1428[48];
    uint32_t dword1458;
    uint32_t dword145C;
    uint32_t ptr20_1460;
    uint32_t dword1464;
    uint32_t mapptr20_1468;
    uint32_t dword146C;
    uint32_t ptr20_1470;
    uint32_t dword1474;
    uint32_t dword1478;
    uint32_t dword147C;
    uint32_t dword1480;
    uint32_t dword1484;
    uint32_t dword1488;
    uint32_t dword148C;
    uint32_t dword1490;
    uint32_t dword1494;
    SomethingCreature som_c;
    uint32_t dword1D28;
    uint32_t float1D2C;
    uint8_t f1D30[8];
    uint8_t byte1D38;
    uint8_t f1D39[3];
    uint32_t dword1D3C;
    uint32_t dword1D40;
    uint32_t dword1D44;
    uint16_t word1D48;
    uint8_t f1D4A[2];
    uint32_t dword1D4C;
    uint32_t dword1D50;
    uint16_t word1D54;
    uint8_t byte1D56;
    uint8_t f1D57[1];
    uint16_t word1D58;
    uint8_t f1D5A[2];
    int8_t char1D5C[256];
    uint32_t dword1E5C;
};
static_assert(sizeof(Creature) == 7776,
              "Invalid size for Creature");
struct HitPacket // size 72
{
    uint64_t entity_id;
    uint64_t target_id;
    float damage;
    uint8_t critical;
    int8_t pad4[3];
    uint32_t stun_duration;
    uint32_t something8;
    qvec3 pos;
    vec3 hit_dir;
    uint8_t skill_hit;
    uint8_t hit_type;
    uint8_t show_light;
    int8_t pad12[1];
};
static_assert(sizeof(HitPacket) == 72,
              "Invalid size for HitPacket");
struct ParticleData // size 72
{
    qvec3 pos;
    vec3 accel;
    float color[4];
    float scale;
    uint32_t count;
    uint32_t particle_type;
    float spreading;
    uint32_t something18;
};
static_assert(sizeof(ParticleData) == 72,
              "Invalid size for ParticleData");
struct SoundAction // size 24
{
    vec3 pos;
    uint32_t sound_index;
    float pitch;
    float volume;
};
static_assert(sizeof(SoundAction) == 24,
              "Invalid size for SoundAction");
struct BlockAction // size 20
{
    ivec3 block_pos;
    uint8_t color_red;
    uint8_t color_green;
    uint8_t color_blue;
    uint8_t block_type;
    uint32_t something8;
};
static_assert(sizeof(BlockAction) == 20,
              "Invalid size for BlockAction");
struct ShootPacket // size 112
{
    uint64_t entity_id;
    int32_t chunk_x;
    int32_t chunk_y;
    uint32_t something5;
    int8_t pad4[4];
    qvec3 pos;
    uint32_t something13;
    uint32_t something14;
    uint32_t something15;
    vec3 velocity;
    float legacy_damage;
    float something20;
    float scale;
    float mana;
    uint32_t particles;
    uint8_t skill;
    int8_t pad16[3];
    uint32_t projectile;
    uint8_t something26;
    int8_t pad19[3];
    uint32_t something27;
    uint32_t something28;
};
static_assert(sizeof(ShootPacket) == 112,
              "Invalid size for ShootPacket");
struct PickupAction // size 288
{
    uint64_t entity_id;
    ItemData item_data;
};
static_assert(sizeof(PickupAction) == 288,
              "Invalid size for PickupAction");
struct KillAction // size 24
{
    uint64_t entity_id;
    uint64_t target_id;
    int8_t pad2[4];
    int32_t xp_gained;
};
static_assert(sizeof(KillAction) == 24,
              "Invalid size for KillAction");
struct DamageAction // size 24
{
    uint64_t target_id;
    uint64_t entity_id;
    float damage;
    int8_t skip[4];
};
static_assert(sizeof(DamageAction) == 24,
              "Invalid size for DamageAction");
struct PassivePacket // size 40
{
    uint64_t entity_id;
    uint64_t target_id;
    uint8_t passive_type;
    int8_t pad3[3];
    float modifier;
    uint32_t duration;
    int8_t pad6[4];
    uint64_t target_id2;
};
static_assert(sizeof(PassivePacket) == 40,
              "Invalid size for PassivePacket");
struct MissionInfo // size 40
{
    uint32_t something3;
    uint32_t mission_id;
    uint32_t mission_desc_id;
    uint32_t monster_race_id;
    uint32_t monster_level;
    uint8_t something8;
    uint8_t state;
    int8_t pad7[2];
    float progress_bar_current;
    float progress_bar_max;
    uint32_t chunk_x;
    uint32_t chunk_y;
};
static_assert(sizeof(MissionInfo) == 40,
              "Invalid size for MissionInfo");
struct MissionPacket // size 56
{
    int32_t x;
    int32_t y;
    uint32_t something1;
    uint32_t something2;
    MissionInfo info;
};
static_assert(sizeof(MissionPacket) == 56,
              "Invalid size for MissionPacket");
struct MissionData // size 96
{
    uint64_t origin_x;
    uint64_t origin_y;
    uint32_t size;
    float unk_float;
    uint32_t place_category_id;
    uint32_t place_item_id;
    uint32_t namegen_id;
    uint32_t area_level;
    uint32_t dword28;
    MissionInfo info;
    uint32_t dword54;
    uint32_t dword58;
    uint8_t byte5C;
    int8_t pad13[3];
};
static_assert(sizeof(MissionData) == 96,
              "Invalid size for MissionData");
struct RegionSomething // size 16
{
    int32_t field_0;
    int32_t field_4;
    int32_t field_8;
    int8_t field_C;
    int8_t pad4[3];
};
static_assert(sizeof(RegionSomething) == 16,
              "Invalid size for RegionSomething");
struct RegionSeed // size 28
{
    uint32_t dword0;
    uint32_t dword4;
    uint8_t byte8;
    int8_t pad3[3];
    float floatC;
    float float10;
    uint32_t dword14;
    uint32_t dword18;
};
static_assert(sizeof(RegionSeed) == 28,
              "Invalid size for RegionSeed");
struct Region // size 88104
{
    uint32_t vtable;
    int8_t pad1[4];
    uint8_t set_to_one1;
    int8_t pad3[3];
    uint32_t set_to_one2;
    uint32_t dword10;
    uint32_t dword14;
    RegionSomething regsomething[4096];
    uint32_t zones[4096];
    MissionData missions[64];
    int8_t byte15A18;
    int8_t pad11[3];
    uint32_t dword15A1C;
    uint32_t dword15A20;
    uint32_t dword15A24;
};
static_assert(sizeof(Region) == 88104,
              "Invalid size for Region");
struct AirshipData // size 128
{
    uint64_t entity_id;
    uint8_t something1;
    int8_t pad2[3];
    uint32_t something2;
    qvec3 pos;
    vec3 velocity;
    vec3 rotation;
    qvec3 start_pos;
    float path_rotation;
    uint32_t something3;
    qvec3 dest_pos;
    uint8_t stage;
    int8_t pad12[3];
    uint8_t something4;
    int8_t pad14[3];
};
static_assert(sizeof(AirshipData) == 128,
              "Invalid size for AirshipData");
struct HitPacketList // size 80
{
    uint32_t next;
    uint32_t prev;
    HitPacket data;
};
static_assert(sizeof(HitPacketList) == 80,
              "Invalid size for HitPacketList");
struct ParticleDataList // size 80
{
    uint32_t next;
    uint32_t prev;
    ParticleData data;
};
static_assert(sizeof(ParticleDataList) == 80,
              "Invalid size for ParticleDataList");
struct SoundActionList // size 32
{
    uint32_t next;
    uint32_t prev;
    SoundAction data;
};
static_assert(sizeof(SoundActionList) == 32,
              "Invalid size for SoundActionList");
struct BlockActionList // size 28
{
    uint32_t next;
    uint32_t prev;
    BlockAction data;
};
static_assert(sizeof(BlockActionList) == 28,
              "Invalid size for BlockActionList");
struct ShootPacketList // size 120
{
    uint32_t next;
    uint32_t prev;
    ShootPacket data;
};
static_assert(sizeof(ShootPacketList) == 120,
              "Invalid size for ShootPacketList");
struct ChunkItemList // size 336
{
    uint32_t next;
    uint32_t prev;
    ChunkItemData data;
};
static_assert(sizeof(ChunkItemList) == 336,
              "Invalid size for ChunkItemList");
struct ChunkItemsList // size 20
{
    uint32_t next;
    uint32_t prev;
    int32_t chunk_x;
    int32_t chunk_y;
    uint32_t data;
};
static_assert(sizeof(ChunkItemsList) == 20,
              "Invalid size for ChunkItemsList");
struct StaticEntityList // size 80
{
    uint32_t next;
    uint32_t prev;
    StaticEntityHeader data;
};
static_assert(sizeof(StaticEntityList) == 80,
              "Invalid size for StaticEntityList");
struct Items8List_2 // size 24
{
    uint32_t next;
    uint32_t prev;
    uint8_t data[16];
};
static_assert(sizeof(Items8List_2) == 24,
              "Invalid size for Items8List_2");
struct Items8List_1 // size 40
{
    uint32_t next;
    uint32_t prev;
    uint64_t something;
    Items8List_2 data;
};
static_assert(sizeof(Items8List_1) == 40,
              "Invalid size for Items8List_1");
struct PickupActionList // size 296
{
    uint32_t next;
    uint32_t prev;
    PickupAction data;
};
static_assert(sizeof(PickupActionList) == 296,
              "Invalid size for PickupActionList");
struct KillActionList // size 32
{
    uint32_t next;
    uint32_t prev;
    KillAction data;
};
static_assert(sizeof(KillActionList) == 32,
              "Invalid size for KillActionList");
struct DamageActionList // size 32
{
    uint32_t next;
    uint32_t prev;
    DamageAction data;
};
static_assert(sizeof(DamageActionList) == 32,
              "Invalid size for DamageActionList");
struct PassivePacketList // size 48
{
    uint32_t next;
    uint32_t prev;
    PassivePacket data;
};
static_assert(sizeof(PassivePacketList) == 48,
              "Invalid size for PassivePacketList");
struct MissionPacketList // size 64
{
    uint32_t next;
    uint32_t prev;
    MissionPacket data;
};
static_assert(sizeof(MissionPacketList) == 64,
              "Invalid size for MissionPacketList");
struct PacketQueue // size 104
{
    uint32_t player_hits;
    uint32_t player_hits_size;
    uint32_t sound_actions;
    uint32_t sound_actions_size;
    uint32_t particles;
    uint32_t particles_size;
    uint32_t block_actions;
    uint32_t block_actions_size;
    uint32_t shoot_packets;
    uint32_t shoot_packets_size;
    uint32_t chunk_items;
    uint32_t chunk_items_size;
    uint32_t static_entities;
    uint32_t static_entities_size;
    uint32_t items_8;
    uint32_t items_8_size;
    uint32_t pickup_actions;
    uint32_t pickup_actions_size;
    uint32_t kill_actions;
    uint32_t kill_actions_size;
    uint32_t damage_actions;
    uint32_t damage_actions_size;
    uint32_t passive_packets;
    uint32_t passive_packets_size;
    uint32_t missions;
    uint32_t missions_size;
};
static_assert(sizeof(PacketQueue) == 104,
              "Invalid size for PacketQueue");
